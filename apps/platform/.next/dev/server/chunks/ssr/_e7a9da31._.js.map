{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/bobkata/Projects/boostcart/apps/platform/src/components/admin/polaris-button.tsx"],"sourcesContent":["import { Slot as SlotPrimitive } from \"radix-ui\";\nimport type React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface PolarisButtonProps\n\textends React.ButtonHTMLAttributes<HTMLButtonElement> {\n\tchildren: React.ReactNode;\n\tsize?: \"micro\" | \"slim\" | \"medium\" | \"large\";\n\tfullWidth?: boolean;\n\tloading?: boolean;\n\tdisabled?: boolean;\n\ticon?: React.ReactNode;\n\tasChild?: boolean;\n}\n\nexport function PolarisButton({\n\tchildren,\n\tsize = \"slim\",\n\tfullWidth = false,\n\tloading = false,\n\tdisabled = false,\n\ticon,\n\tasChild = false,\n\tclassName,\n\t...props\n}: PolarisButtonProps) {\n\tconst Comp = asChild ? SlotPrimitive.Slot : \"button\";\n\tconst sizeClasses = {\n\t\tmicro: \"h-7 px-2.5 text-xs\",\n\t\tslim: \"h-9 px-3 text-sm\",\n\t\tmedium: \"h-10 px-4 text-sm\",\n\t\tlarge: \"h-12 px-5 text-base\",\n\t};\n\n\treturn (\n\t\t<Comp\n\t\t\tdisabled={disabled || loading}\n\t\t\tclassName={cn(\n\t\t\t\t// Base styles matching Polaris primary button\n\t\t\t\t\"relative inline-flex items-center justify-center gap-2\",\n\t\t\t\t\"font-semibold rounded-[10px] cursor-pointer\",\n\t\t\t\t\"transition-all duration-200 ease-out\",\n\t\t\t\t\"outline-none focus-visible:outline-2 focus-visible:outline-offset-2\",\n\n\t\t\t\t\"border-0\",\n\t\t\t\t\"shadow-[inset_0_1.5px_0_0_rgba(0,0,0,0.6),inset_1.5px_0_0_0_rgba(0,0,0,0.8),inset_-1.5px_0_0_0_rgba(0,0,0,0.8),inset_0_-3px_0_0_rgba(0,0,0,0.8)]\",\n\n\t\t\t\t\"bg-linear-to-b from-[#4a4a4a] to-[#303030]\",\n\n\t\t\t\t// Text colors from Polaris tokens\n\t\t\t\t\"text-white\",\n\n\t\t\t\t\"hover:before:absolute hover:before:inset-0 hover:before:rounded-[10px] hover:before:bg-black hover:before:opacity-30 hover:before:transition-opacity hover:before:duration-200 hover:before:content-['']\",\n\n\t\t\t\t// Disabled state\n\t\t\t\t\"disabled:bg-linear-to-b disabled:from-[rgba(0,0,0,0.2)] disabled:to-[rgba(0,0,0,0.17)]\",\n\t\t\t\t\"disabled:text-[rgba(255,255,255,0.6)]\",\n\t\t\t\t\"disabled:cursor-not-allowed\",\n\t\t\t\t\"disabled:shadow-[inset_0_1.5px_0_0_rgba(0,0,0,0.2),inset_1.5px_0_0_0_rgba(0,0,0,0.2),inset_-1.5px_0_0_0_rgba(0,0,0,0.2),inset_0_-3px_0_0_rgba(0,0,0,0.2)]\",\n\t\t\t\t\"disabled:hover:before:opacity-0\",\n\n\t\t\t\t// Focus state border\n\t\t\t\t\"focus-visible:outline-[#005BD3]\",\n\n\t\t\t\t\"active:shadow-[inset_0_4px_0_0_rgba(0,0,0,0.8),inset_1.5px_0_0_0_rgba(0,0,0,0.8),inset_-1.5px_0_0_0_rgba(0,0,0,0.8),inset_0_-3px_0_0_rgba(0,0,0,0.8)]\",\n\t\t\t\t\"active:bg-linear-to-b active:from-[#2a2a2a] active:to-[#1a1a1a]\",\n\t\t\t\t\"active:[&>span:last-child]:translate-y-px\",\n\n\t\t\t\t// Size variants\n\t\t\t\tsizeClasses[size],\n\n\t\t\t\t// Full width\n\t\t\t\tfullWidth && \"w-full\",\n\n\t\t\t\tasChild && disabled && \"pointer-events-none opacity-50\",\n\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t<span className=\"absolute inset-0 rounded-[10px] pointer-events-none shadow-[inset_0_3px_0_0_rgba(255,255,255,0.2),inset_1.5px_0_0_0_rgba(255,255,255,0.1),inset_-1.5px_0_0_0_rgba(255,255,255,0.1)] active:opacity-0 transition-opacity duration-200\" />\n\n\t\t\t<span className=\"relative flex items-center justify-center gap-2 transition-transform duration-200\">\n\t\t\t\t{loading ? (\n\t\t\t\t\t<svg\n\t\t\t\t\t\tclassName=\"animate-spin size-4\"\n\t\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\t\tfill=\"none\"\n\t\t\t\t\t\tviewBox=\"0 0 24 24\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<title>Loading</title>\n\t\t\t\t\t\t<circle\n\t\t\t\t\t\t\tclassName=\"opacity-25\"\n\t\t\t\t\t\t\tcx=\"12\"\n\t\t\t\t\t\t\tcy=\"12\"\n\t\t\t\t\t\t\tr=\"10\"\n\t\t\t\t\t\t\tstroke=\"currentColor\"\n\t\t\t\t\t\t\tstrokeWidth=\"4\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<path\n\t\t\t\t\t\t\tclassName=\"opacity-75\"\n\t\t\t\t\t\t\tfill=\"currentColor\"\n\t\t\t\t\t\t\td=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</svg>\n\t\t\t\t) : (\n\t\t\t\t\ticon && <span className=\"shrink-0\">{icon}</span>\n\t\t\t\t)}\n\t\t\t\t{children}\n\t\t\t</span>\n\t\t</Comp>\n\t);\n}\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAaO,SAAS,cAAc,EAC7B,QAAQ,EACR,OAAO,MAAM,EACb,YAAY,KAAK,EACjB,UAAU,KAAK,EACf,WAAW,KAAK,EAChB,IAAI,EACJ,UAAU,KAAK,EACf,SAAS,EACT,GAAG,OACiB;IACpB,MAAM,OAAO,UAAU,uOAAa,CAAC,IAAI,GAAG;IAC5C,MAAM,cAAc;QACnB,OAAO;QACP,MAAM;QACN,QAAQ;QACR,OAAO;IACR;IAEA,qBACC,8OAAC;QACA,UAAU,YAAY;QACtB,WAAW,IAAA,6IAAE,EACZ,8CAA8C;QAC9C,0DACA,+CACA,wCACA,uEAEA,YACA,oJAEA,8CAEA,kCAAkC;QAClC,cAEA,4MAEA,iBAAiB;QACjB,0FACA,yCACA,+BACA,6JACA,mCAEA,qBAAqB;QACrB,mCAEA,yJACA,mEACA,6CAEA,gBAAgB;QAChB,WAAW,CAAC,KAAK,EAEjB,aAAa;QACb,aAAa,UAEb,WAAW,YAAY,kCAEvB;QAEA,GAAG,KAAK;;0BAET,8OAAC;gBAAK,WAAU;;;;;;0BAEhB,8OAAC;gBAAK,WAAU;;oBACd,wBACA,8OAAC;wBACA,WAAU;wBACV,OAAM;wBACN,MAAK;wBACL,SAAQ;;0CAER,8OAAC;0CAAM;;;;;;0CACP,8OAAC;gCACA,WAAU;gCACV,IAAG;gCACH,IAAG;gCACH,GAAE;gCACF,QAAO;gCACP,aAAY;;;;;;0CAEb,8OAAC;gCACA,WAAU;gCACV,MAAK;gCACL,GAAE;;;;;;;;;;;+BAIJ,sBAAQ,8OAAC;wBAAK,WAAU;kCAAY;;;;;;oBAEpC;;;;;;;;;;;;;AAIL"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///Users/bobkata/Projects/boostcart/apps/platform/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst Card = React.forwardRef<\n\tHTMLDivElement,\n\tReact.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n\t<div\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"rounded-lg border bg-card text-card-foreground shadow-sm\",\n\t\t\tclassName,\n\t\t)}\n\t\t{...props}\n\t/>\n));\nCard.displayName = \"Card\";\n\nconst CardHeader = React.forwardRef<\n\tHTMLDivElement,\n\tReact.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n\t<div\n\t\tref={ref}\n\t\tclassName={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n\t\t{...props}\n\t/>\n));\nCardHeader.displayName = \"CardHeader\";\n\nconst CardTitle = React.forwardRef<\n\tHTMLDivElement,\n\tReact.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n\t<div\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"text-2xl font-semibold leading-none tracking-tight\",\n\t\t\tclassName,\n\t\t)}\n\t\t{...props}\n\t/>\n));\nCardTitle.displayName = \"CardTitle\";\n\nconst CardDescription = React.forwardRef<\n\tHTMLDivElement,\n\tReact.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n\t<div\n\t\tref={ref}\n\t\tclassName={cn(\"text-sm text-muted-foreground\", className)}\n\t\t{...props}\n\t/>\n));\nCardDescription.displayName = \"CardDescription\";\n\nconst CardContent = React.forwardRef<\n\tHTMLDivElement,\n\tReact.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n\t<div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n));\nCardContent.displayName = \"CardContent\";\n\nconst CardFooter = React.forwardRef<\n\tHTMLDivElement,\n\tReact.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n\t<div\n\t\tref={ref}\n\t\tclassName={cn(\"flex items-center p-6 pt-0\", className)}\n\t\t{...props}\n\t/>\n));\nCardFooter.displayName = \"CardFooter\";\n\nexport {\n\tCard,\n\tCardHeader,\n\tCardFooter,\n\tCardTitle,\n\tCardDescription,\n\tCardContent,\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,mNAAgB,CAG3B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QACA,KAAK;QACL,WAAW,IAAA,6IAAE,EACZ,4DACA;QAEA,GAAG,KAAK;;;;;;AAGX,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,mNAAgB,CAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QACA,KAAK;QACL,WAAW,IAAA,6IAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGX,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,mNAAgB,CAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QACA,KAAK;QACL,WAAW,IAAA,6IAAE,EACZ,sDACA;QAEA,GAAG,KAAK;;;;;;AAGX,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,mNAAgB,CAGtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QACA,KAAK;QACL,WAAW,IAAA,6IAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGX,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,mNAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,6IAAE,EAAC,YAAY;QAAa,GAAG,KAAK;;;;;;AAE/D,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,mNAAgB,CAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QACA,KAAK;QACL,WAAW,IAAA,6IAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGX,WAAW,WAAW,GAAG"}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["file:///Users/bobkata/Projects/boostcart/apps/platform/src/components/ui/table.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst Table = React.forwardRef<\n\tHTMLTableElement,\n\tReact.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n\t<div className=\"relative w-full overflow-auto\">\n\t\t<table\n\t\t\tref={ref}\n\t\t\tclassName={cn(\"w-full caption-bottom text-sm\", className)}\n\t\t\t{...props}\n\t\t/>\n\t</div>\n));\nTable.displayName = \"Table\";\n\nconst TableHeader = React.forwardRef<\n\tHTMLTableSectionElement,\n\tReact.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n\t<thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n));\nTableHeader.displayName = \"TableHeader\";\n\nconst TableBody = React.forwardRef<\n\tHTMLTableSectionElement,\n\tReact.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n\t<tbody\n\t\tref={ref}\n\t\tclassName={cn(\"[&_tr:last-child]:border-0\", className)}\n\t\t{...props}\n\t/>\n));\nTableBody.displayName = \"TableBody\";\n\nconst TableFooter = React.forwardRef<\n\tHTMLTableSectionElement,\n\tReact.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n\t<tfoot\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n\t\t\tclassName,\n\t\t)}\n\t\t{...props}\n\t/>\n));\nTableFooter.displayName = \"TableFooter\";\n\nconst TableRow = React.forwardRef<\n\tHTMLTableRowElement,\n\tReact.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n\t<tr\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n\t\t\tclassName,\n\t\t)}\n\t\t{...props}\n\t/>\n));\nTableRow.displayName = \"TableRow\";\n\nconst TableHead = React.forwardRef<\n\tHTMLTableCellElement,\n\tReact.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n\t<th\n\t\tref={ref}\n\t\tclassName={cn(\n\t\t\t\"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n\t\t\tclassName,\n\t\t)}\n\t\t{...props}\n\t/>\n));\nTableHead.displayName = \"TableHead\";\n\nconst TableCell = React.forwardRef<\n\tHTMLTableCellElement,\n\tReact.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n\t<td\n\t\tref={ref}\n\t\tclassName={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\n\t\t{...props}\n\t/>\n));\nTableCell.displayName = \"TableCell\";\n\nconst TableCaption = React.forwardRef<\n\tHTMLTableCaptionElement,\n\tReact.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n\t<caption\n\t\tref={ref}\n\t\tclassName={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n\t\t{...props}\n\t/>\n));\nTableCaption.displayName = \"TableCaption\";\n\nexport {\n\tTable,\n\tTableHeader,\n\tTableBody,\n\tTableFooter,\n\tTableHead,\n\tTableRow,\n\tTableCell,\n\tTableCaption,\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,mNAAgB,CAG5B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QAAI,WAAU;kBACd,cAAA,8OAAC;YACA,KAAK;YACL,WAAW,IAAA,6IAAE,EAAC,iCAAiC;YAC9C,GAAG,KAAK;;;;;;;;;;;AAIZ,MAAM,WAAW,GAAG;AAEpB,MAAM,4BAAc,mNAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QAAM,KAAK;QAAK,WAAW,IAAA,6IAAE,EAAC,mBAAmB;QAAa,GAAG,KAAK;;;;;;AAExE,YAAY,WAAW,GAAG;AAE1B,MAAM,0BAAY,mNAAgB,CAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QACA,KAAK;QACL,WAAW,IAAA,6IAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGX,UAAU,WAAW,GAAG;AAExB,MAAM,4BAAc,mNAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QACA,KAAK;QACL,WAAW,IAAA,6IAAE,EACZ,2DACA;QAEA,GAAG,KAAK;;;;;;AAGX,YAAY,WAAW,GAAG;AAE1B,MAAM,yBAAW,mNAAgB,CAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QACA,KAAK;QACL,WAAW,IAAA,6IAAE,EACZ,+EACA;QAEA,GAAG,KAAK;;;;;;AAGX,SAAS,WAAW,GAAG;AAEvB,MAAM,0BAAY,mNAAgB,CAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QACA,KAAK;QACL,WAAW,IAAA,6IAAE,EACZ,oGACA;QAEA,GAAG,KAAK;;;;;;AAGX,UAAU,WAAW,GAAG;AAExB,MAAM,0BAAY,mNAAgB,CAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QACA,KAAK;QACL,WAAW,IAAA,6IAAE,EAAC,kDAAkD;QAC/D,GAAG,KAAK;;;;;;AAGX,UAAU,WAAW,GAAG;AAExB,MAAM,6BAAe,mNAAgB,CAGnC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC3B,8OAAC;QACA,KAAK;QACL,WAAW,IAAA,6IAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAGX,aAAa,WAAW,GAAG"}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":["file:///Users/bobkata/Projects/boostcart/apps/platform/src/server/api/internal/blog.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/server/auth\";\nimport { db } from \"@/server/db\";\nimport { requireAdminTenant } from \"@/server/tenant\";\n\nasync function requireStoreAccess() {\n\tconst session = await auth();\n\tif (!session?.user?.id) {\n\t\tthrow new Error(\"Unauthorized\");\n\t}\n\n\tconst tenant = await requireAdminTenant();\n\n\tconst staffRecord = await db.tenantStaff.findFirst({\n\t\twhere: {\n\t\t\tuserId: session.user.id,\n\t\t\ttenantId: tenant.id,\n\t\t},\n\t});\n\n\tif (!staffRecord) {\n\t\tthrow new Error(\"Forbidden: No access to this store\");\n\t}\n\n\treturn {\n\t\tuserId: session.user.id,\n\t\ttenantId: tenant.id,\n\t\trole: staffRecord.role,\n\t};\n}\n\nexport async function getBlogPosts() {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst posts = await db.blogPost.findMany({\n\t\twhere: { tenantId },\n\t\tinclude: {\n\t\t\ttranslations: {\n\t\t\t\tinclude: {\n\t\t\t\t\tlocale: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\torderBy: { createdAt: \"desc\" },\n\t});\n\n\treturn posts.map((post) => ({\n\t\tid: post.id,\n\t\tslug: post.slug,\n\t\tfeaturedImage: post.featuredImage,\n\t\tauthor: post.author,\n\t\tisPublished: post.isPublished,\n\t\tpublishedAt: post.publishedAt,\n\t\ttitle: post.translations[0]?.title ?? post.slug,\n\t\texcerpt: post.translations[0]?.excerpt ?? \"\",\n\t\tcontent: post.translations[0]?.content ?? \"\",\n\t\ttranslations: post.translations.map((t) => ({\n\t\t\tlocaleId: t.localeId,\n\t\t\tlocaleCode: t.locale.code,\n\t\t\tlocaleName: t.locale.name,\n\t\t\ttitle: t.title,\n\t\t\texcerpt: t.excerpt,\n\t\t\tcontent: t.content,\n\t\t})),\n\t\tcreatedAt: post.createdAt,\n\t\tupdatedAt: post.updatedAt,\n\t}));\n}\n\nexport async function getBlogPost(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t\tinclude: {\n\t\t\ttranslations: {\n\t\t\t\tinclude: {\n\t\t\t\t\tlocale: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found\");\n\t}\n\n\treturn {\n\t\tid: post.id,\n\t\tslug: post.slug,\n\t\tfeaturedImage: post.featuredImage,\n\t\tauthor: post.author,\n\t\tisPublished: post.isPublished,\n\t\tpublishedAt: post.publishedAt,\n\t\ttranslations: post.translations.map((t) => ({\n\t\t\tid: t.id,\n\t\t\tlocaleId: t.localeId,\n\t\t\tlocaleCode: t.locale.code,\n\t\t\tlocaleName: t.locale.name,\n\t\t\ttitle: t.title,\n\t\t\texcerpt: t.excerpt,\n\t\t\tcontent: t.content,\n\t\t})),\n\t\tcreatedAt: post.createdAt,\n\t\tupdatedAt: post.updatedAt,\n\t};\n}\n\nexport interface CreateBlogPostInput {\n\tslug: string;\n\tfeaturedImage?: string;\n\tauthor?: string;\n\tisPublished?: boolean;\n\tpublishedAt?: Date;\n\ttranslations: {\n\t\tlocaleId: string;\n\t\ttitle: string;\n\t\texcerpt?: string;\n\t\tcontent: string;\n\t}[];\n}\n\nexport async function createBlogPost(input: CreateBlogPostInput) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\t// Check for duplicate slug\n\tconst existing = await db.blogPost.findUnique({\n\t\twhere: {\n\t\t\ttenantId_slug: {\n\t\t\t\ttenantId,\n\t\t\t\tslug: input.slug,\n\t\t\t},\n\t\t},\n\t});\n\n\tif (existing) {\n\t\tthrow new Error(\"A blog post with this slug already exists\");\n\t}\n\n\tconst post = await db.blogPost.create({\n\t\tdata: {\n\t\t\tslug: input.slug,\n\t\t\tfeaturedImage: input.featuredImage,\n\t\t\tauthor: input.author,\n\t\t\tisPublished: input.isPublished ?? false,\n\t\t\tpublishedAt: input.isPublished ? (input.publishedAt ?? new Date()) : null,\n\t\t\ttenantId,\n\t\t\ttranslations: {\n\t\t\t\tcreate: input.translations.map((t) => ({\n\t\t\t\t\tlocaleId: t.localeId,\n\t\t\t\t\ttitle: t.title,\n\t\t\t\t\texcerpt: t.excerpt,\n\t\t\t\t\tcontent: t.content,\n\t\t\t\t})),\n\t\t\t},\n\t\t},\n\t\tinclude: {\n\t\t\ttranslations: true,\n\t\t},\n\t});\n\n\treturn post;\n}\n\nexport interface UpdateBlogPostInput {\n\tslug?: string;\n\tfeaturedImage?: string | null;\n\tauthor?: string;\n\tisPublished?: boolean;\n\tpublishedAt?: Date | null;\n\ttranslations?: {\n\t\tlocaleId: string;\n\t\ttitle: string;\n\t\texcerpt?: string;\n\t\tcontent: string;\n\t}[];\n}\n\nexport async function updateBlogPost(id: string, input: UpdateBlogPostInput) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\t// Check for duplicate slug if changing\n\tif (input.slug && input.slug !== post.slug) {\n\t\tconst existing = await db.blogPost.findUnique({\n\t\t\twhere: {\n\t\t\t\ttenantId_slug: {\n\t\t\t\t\ttenantId,\n\t\t\t\t\tslug: input.slug,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\tif (existing) {\n\t\t\tthrow new Error(\"A blog post with this slug already exists\");\n\t\t}\n\t}\n\n\t// Handle publish state change\n\tlet publishedAt = input.publishedAt;\n\tif (input.isPublished !== undefined) {\n\t\tif (input.isPublished && !post.isPublished) {\n\t\t\t// Publishing for the first time\n\t\t\tpublishedAt = publishedAt ?? new Date();\n\t\t} else if (!input.isPublished) {\n\t\t\t// Unpublishing\n\t\t\tpublishedAt = null;\n\t\t}\n\t}\n\n\tconst updated = await db.blogPost.update({\n\t\twhere: { id },\n\t\tdata: {\n\t\t\tslug: input.slug,\n\t\t\tfeaturedImage: input.featuredImage,\n\t\t\tauthor: input.author,\n\t\t\tisPublished: input.isPublished,\n\t\t\tpublishedAt,\n\t\t\t...(input.translations && {\n\t\t\t\ttranslations: {\n\t\t\t\t\tdeleteMany: {},\n\t\t\t\t\tcreate: input.translations.map((t) => ({\n\t\t\t\t\t\tlocaleId: t.localeId,\n\t\t\t\t\t\ttitle: t.title,\n\t\t\t\t\t\texcerpt: t.excerpt,\n\t\t\t\t\t\tcontent: t.content,\n\t\t\t\t\t})),\n\t\t\t\t},\n\t\t\t}),\n\t\t},\n\t\tinclude: {\n\t\t\ttranslations: true,\n\t\t},\n\t});\n\n\treturn updated;\n}\n\nexport async function deleteBlogPost(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\tawait db.blogPost.delete({\n\t\twhere: { id },\n\t});\n\n\treturn { success: true };\n}\n\nexport async function toggleBlogPostPublished(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\tconst isPublished = !post.isPublished;\n\tconst publishedAt = isPublished\n\t\t? post.publishedAt ?? new Date()\n\t\t: post.publishedAt;\n\n\tconst updated = await db.blogPost.update({\n\t\twhere: { id },\n\t\tdata: {\n\t\t\tisPublished,\n\t\t\tpublishedAt,\n\t\t},\n\t});\n\n\treturn updated;\n}\n\nexport async function getBlogStats() {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst [total, published, drafts] = await Promise.all([\n\t\tdb.blogPost.count({ where: { tenantId } }),\n\t\tdb.blogPost.count({ where: { tenantId, isPublished: true } }),\n\t\tdb.blogPost.count({ where: { tenantId, isPublished: false } }),\n\t]);\n\n\t// Get recent posts (last 7 days)\n\tconst weekAgo = new Date();\n\tweekAgo.setDate(weekAgo.getDate() - 7);\n\n\tconst recent = await db.blogPost.count({\n\t\twhere: {\n\t\t\ttenantId,\n\t\t\tcreatedAt: { gte: weekAgo },\n\t\t},\n\t});\n\n\treturn {\n\t\ttotal,\n\t\tpublished,\n\t\tdrafts,\n\t\trecent,\n\t};\n}\n"],"names":[],"mappings":";;;;;;;MAsPsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,kDAAA"}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":["file:///Users/bobkata/Projects/boostcart/apps/platform/src/server/api/internal/blog.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/server/auth\";\nimport { db } from \"@/server/db\";\nimport { requireAdminTenant } from \"@/server/tenant\";\n\nasync function requireStoreAccess() {\n\tconst session = await auth();\n\tif (!session?.user?.id) {\n\t\tthrow new Error(\"Unauthorized\");\n\t}\n\n\tconst tenant = await requireAdminTenant();\n\n\tconst staffRecord = await db.tenantStaff.findFirst({\n\t\twhere: {\n\t\t\tuserId: session.user.id,\n\t\t\ttenantId: tenant.id,\n\t\t},\n\t});\n\n\tif (!staffRecord) {\n\t\tthrow new Error(\"Forbidden: No access to this store\");\n\t}\n\n\treturn {\n\t\tuserId: session.user.id,\n\t\ttenantId: tenant.id,\n\t\trole: staffRecord.role,\n\t};\n}\n\nexport async function getBlogPosts() {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst posts = await db.blogPost.findMany({\n\t\twhere: { tenantId },\n\t\tinclude: {\n\t\t\ttranslations: {\n\t\t\t\tinclude: {\n\t\t\t\t\tlocale: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\torderBy: { createdAt: \"desc\" },\n\t});\n\n\treturn posts.map((post) => ({\n\t\tid: post.id,\n\t\tslug: post.slug,\n\t\tfeaturedImage: post.featuredImage,\n\t\tauthor: post.author,\n\t\tisPublished: post.isPublished,\n\t\tpublishedAt: post.publishedAt,\n\t\ttitle: post.translations[0]?.title ?? post.slug,\n\t\texcerpt: post.translations[0]?.excerpt ?? \"\",\n\t\tcontent: post.translations[0]?.content ?? \"\",\n\t\ttranslations: post.translations.map((t) => ({\n\t\t\tlocaleId: t.localeId,\n\t\t\tlocaleCode: t.locale.code,\n\t\t\tlocaleName: t.locale.name,\n\t\t\ttitle: t.title,\n\t\t\texcerpt: t.excerpt,\n\t\t\tcontent: t.content,\n\t\t})),\n\t\tcreatedAt: post.createdAt,\n\t\tupdatedAt: post.updatedAt,\n\t}));\n}\n\nexport async function getBlogPost(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t\tinclude: {\n\t\t\ttranslations: {\n\t\t\t\tinclude: {\n\t\t\t\t\tlocale: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found\");\n\t}\n\n\treturn {\n\t\tid: post.id,\n\t\tslug: post.slug,\n\t\tfeaturedImage: post.featuredImage,\n\t\tauthor: post.author,\n\t\tisPublished: post.isPublished,\n\t\tpublishedAt: post.publishedAt,\n\t\ttranslations: post.translations.map((t) => ({\n\t\t\tid: t.id,\n\t\t\tlocaleId: t.localeId,\n\t\t\tlocaleCode: t.locale.code,\n\t\t\tlocaleName: t.locale.name,\n\t\t\ttitle: t.title,\n\t\t\texcerpt: t.excerpt,\n\t\t\tcontent: t.content,\n\t\t})),\n\t\tcreatedAt: post.createdAt,\n\t\tupdatedAt: post.updatedAt,\n\t};\n}\n\nexport interface CreateBlogPostInput {\n\tslug: string;\n\tfeaturedImage?: string;\n\tauthor?: string;\n\tisPublished?: boolean;\n\tpublishedAt?: Date;\n\ttranslations: {\n\t\tlocaleId: string;\n\t\ttitle: string;\n\t\texcerpt?: string;\n\t\tcontent: string;\n\t}[];\n}\n\nexport async function createBlogPost(input: CreateBlogPostInput) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\t// Check for duplicate slug\n\tconst existing = await db.blogPost.findUnique({\n\t\twhere: {\n\t\t\ttenantId_slug: {\n\t\t\t\ttenantId,\n\t\t\t\tslug: input.slug,\n\t\t\t},\n\t\t},\n\t});\n\n\tif (existing) {\n\t\tthrow new Error(\"A blog post with this slug already exists\");\n\t}\n\n\tconst post = await db.blogPost.create({\n\t\tdata: {\n\t\t\tslug: input.slug,\n\t\t\tfeaturedImage: input.featuredImage,\n\t\t\tauthor: input.author,\n\t\t\tisPublished: input.isPublished ?? false,\n\t\t\tpublishedAt: input.isPublished ? (input.publishedAt ?? new Date()) : null,\n\t\t\ttenantId,\n\t\t\ttranslations: {\n\t\t\t\tcreate: input.translations.map((t) => ({\n\t\t\t\t\tlocaleId: t.localeId,\n\t\t\t\t\ttitle: t.title,\n\t\t\t\t\texcerpt: t.excerpt,\n\t\t\t\t\tcontent: t.content,\n\t\t\t\t})),\n\t\t\t},\n\t\t},\n\t\tinclude: {\n\t\t\ttranslations: true,\n\t\t},\n\t});\n\n\treturn post;\n}\n\nexport interface UpdateBlogPostInput {\n\tslug?: string;\n\tfeaturedImage?: string | null;\n\tauthor?: string;\n\tisPublished?: boolean;\n\tpublishedAt?: Date | null;\n\ttranslations?: {\n\t\tlocaleId: string;\n\t\ttitle: string;\n\t\texcerpt?: string;\n\t\tcontent: string;\n\t}[];\n}\n\nexport async function updateBlogPost(id: string, input: UpdateBlogPostInput) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\t// Check for duplicate slug if changing\n\tif (input.slug && input.slug !== post.slug) {\n\t\tconst existing = await db.blogPost.findUnique({\n\t\t\twhere: {\n\t\t\t\ttenantId_slug: {\n\t\t\t\t\ttenantId,\n\t\t\t\t\tslug: input.slug,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\tif (existing) {\n\t\t\tthrow new Error(\"A blog post with this slug already exists\");\n\t\t}\n\t}\n\n\t// Handle publish state change\n\tlet publishedAt = input.publishedAt;\n\tif (input.isPublished !== undefined) {\n\t\tif (input.isPublished && !post.isPublished) {\n\t\t\t// Publishing for the first time\n\t\t\tpublishedAt = publishedAt ?? new Date();\n\t\t} else if (!input.isPublished) {\n\t\t\t// Unpublishing\n\t\t\tpublishedAt = null;\n\t\t}\n\t}\n\n\tconst updated = await db.blogPost.update({\n\t\twhere: { id },\n\t\tdata: {\n\t\t\tslug: input.slug,\n\t\t\tfeaturedImage: input.featuredImage,\n\t\t\tauthor: input.author,\n\t\t\tisPublished: input.isPublished,\n\t\t\tpublishedAt,\n\t\t\t...(input.translations && {\n\t\t\t\ttranslations: {\n\t\t\t\t\tdeleteMany: {},\n\t\t\t\t\tcreate: input.translations.map((t) => ({\n\t\t\t\t\t\tlocaleId: t.localeId,\n\t\t\t\t\t\ttitle: t.title,\n\t\t\t\t\t\texcerpt: t.excerpt,\n\t\t\t\t\t\tcontent: t.content,\n\t\t\t\t\t})),\n\t\t\t\t},\n\t\t\t}),\n\t\t},\n\t\tinclude: {\n\t\t\ttranslations: true,\n\t\t},\n\t});\n\n\treturn updated;\n}\n\nexport async function deleteBlogPost(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\tawait db.blogPost.delete({\n\t\twhere: { id },\n\t});\n\n\treturn { success: true };\n}\n\nexport async function toggleBlogPostPublished(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\tconst isPublished = !post.isPublished;\n\tconst publishedAt = isPublished\n\t\t? post.publishedAt ?? new Date()\n\t\t: post.publishedAt;\n\n\tconst updated = await db.blogPost.update({\n\t\twhere: { id },\n\t\tdata: {\n\t\t\tisPublished,\n\t\t\tpublishedAt,\n\t\t},\n\t});\n\n\treturn updated;\n}\n\nexport async function getBlogStats() {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst [total, published, drafts] = await Promise.all([\n\t\tdb.blogPost.count({ where: { tenantId } }),\n\t\tdb.blogPost.count({ where: { tenantId, isPublished: true } }),\n\t\tdb.blogPost.count({ where: { tenantId, isPublished: false } }),\n\t]);\n\n\t// Get recent posts (last 7 days)\n\tconst weekAgo = new Date();\n\tweekAgo.setDate(weekAgo.getDate() - 7);\n\n\tconst recent = await db.blogPost.count({\n\t\twhere: {\n\t\t\ttenantId,\n\t\t\tcreatedAt: { gte: weekAgo },\n\t\t},\n\t});\n\n\treturn {\n\t\ttotal,\n\t\tpublished,\n\t\tdrafts,\n\t\trecent,\n\t};\n}\n"],"names":[],"mappings":";;;;;;;MAgCsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,gDAAA"}},
    {"offset": {"line": 337, "column": 0}, "map": {"version":3,"sources":["file:///Users/bobkata/Projects/boostcart/apps/platform/src/server/api/internal/blog.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/server/auth\";\nimport { db } from \"@/server/db\";\nimport { requireAdminTenant } from \"@/server/tenant\";\n\nasync function requireStoreAccess() {\n\tconst session = await auth();\n\tif (!session?.user?.id) {\n\t\tthrow new Error(\"Unauthorized\");\n\t}\n\n\tconst tenant = await requireAdminTenant();\n\n\tconst staffRecord = await db.tenantStaff.findFirst({\n\t\twhere: {\n\t\t\tuserId: session.user.id,\n\t\t\ttenantId: tenant.id,\n\t\t},\n\t});\n\n\tif (!staffRecord) {\n\t\tthrow new Error(\"Forbidden: No access to this store\");\n\t}\n\n\treturn {\n\t\tuserId: session.user.id,\n\t\ttenantId: tenant.id,\n\t\trole: staffRecord.role,\n\t};\n}\n\nexport async function getBlogPosts() {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst posts = await db.blogPost.findMany({\n\t\twhere: { tenantId },\n\t\tinclude: {\n\t\t\ttranslations: {\n\t\t\t\tinclude: {\n\t\t\t\t\tlocale: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\torderBy: { createdAt: \"desc\" },\n\t});\n\n\treturn posts.map((post) => ({\n\t\tid: post.id,\n\t\tslug: post.slug,\n\t\tfeaturedImage: post.featuredImage,\n\t\tauthor: post.author,\n\t\tisPublished: post.isPublished,\n\t\tpublishedAt: post.publishedAt,\n\t\ttitle: post.translations[0]?.title ?? post.slug,\n\t\texcerpt: post.translations[0]?.excerpt ?? \"\",\n\t\tcontent: post.translations[0]?.content ?? \"\",\n\t\ttranslations: post.translations.map((t) => ({\n\t\t\tlocaleId: t.localeId,\n\t\t\tlocaleCode: t.locale.code,\n\t\t\tlocaleName: t.locale.name,\n\t\t\ttitle: t.title,\n\t\t\texcerpt: t.excerpt,\n\t\t\tcontent: t.content,\n\t\t})),\n\t\tcreatedAt: post.createdAt,\n\t\tupdatedAt: post.updatedAt,\n\t}));\n}\n\nexport async function getBlogPost(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t\tinclude: {\n\t\t\ttranslations: {\n\t\t\t\tinclude: {\n\t\t\t\t\tlocale: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found\");\n\t}\n\n\treturn {\n\t\tid: post.id,\n\t\tslug: post.slug,\n\t\tfeaturedImage: post.featuredImage,\n\t\tauthor: post.author,\n\t\tisPublished: post.isPublished,\n\t\tpublishedAt: post.publishedAt,\n\t\ttranslations: post.translations.map((t) => ({\n\t\t\tid: t.id,\n\t\t\tlocaleId: t.localeId,\n\t\t\tlocaleCode: t.locale.code,\n\t\t\tlocaleName: t.locale.name,\n\t\t\ttitle: t.title,\n\t\t\texcerpt: t.excerpt,\n\t\t\tcontent: t.content,\n\t\t})),\n\t\tcreatedAt: post.createdAt,\n\t\tupdatedAt: post.updatedAt,\n\t};\n}\n\nexport interface CreateBlogPostInput {\n\tslug: string;\n\tfeaturedImage?: string;\n\tauthor?: string;\n\tisPublished?: boolean;\n\tpublishedAt?: Date;\n\ttranslations: {\n\t\tlocaleId: string;\n\t\ttitle: string;\n\t\texcerpt?: string;\n\t\tcontent: string;\n\t}[];\n}\n\nexport async function createBlogPost(input: CreateBlogPostInput) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\t// Check for duplicate slug\n\tconst existing = await db.blogPost.findUnique({\n\t\twhere: {\n\t\t\ttenantId_slug: {\n\t\t\t\ttenantId,\n\t\t\t\tslug: input.slug,\n\t\t\t},\n\t\t},\n\t});\n\n\tif (existing) {\n\t\tthrow new Error(\"A blog post with this slug already exists\");\n\t}\n\n\tconst post = await db.blogPost.create({\n\t\tdata: {\n\t\t\tslug: input.slug,\n\t\t\tfeaturedImage: input.featuredImage,\n\t\t\tauthor: input.author,\n\t\t\tisPublished: input.isPublished ?? false,\n\t\t\tpublishedAt: input.isPublished ? (input.publishedAt ?? new Date()) : null,\n\t\t\ttenantId,\n\t\t\ttranslations: {\n\t\t\t\tcreate: input.translations.map((t) => ({\n\t\t\t\t\tlocaleId: t.localeId,\n\t\t\t\t\ttitle: t.title,\n\t\t\t\t\texcerpt: t.excerpt,\n\t\t\t\t\tcontent: t.content,\n\t\t\t\t})),\n\t\t\t},\n\t\t},\n\t\tinclude: {\n\t\t\ttranslations: true,\n\t\t},\n\t});\n\n\treturn post;\n}\n\nexport interface UpdateBlogPostInput {\n\tslug?: string;\n\tfeaturedImage?: string | null;\n\tauthor?: string;\n\tisPublished?: boolean;\n\tpublishedAt?: Date | null;\n\ttranslations?: {\n\t\tlocaleId: string;\n\t\ttitle: string;\n\t\texcerpt?: string;\n\t\tcontent: string;\n\t}[];\n}\n\nexport async function updateBlogPost(id: string, input: UpdateBlogPostInput) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\t// Check for duplicate slug if changing\n\tif (input.slug && input.slug !== post.slug) {\n\t\tconst existing = await db.blogPost.findUnique({\n\t\t\twhere: {\n\t\t\t\ttenantId_slug: {\n\t\t\t\t\ttenantId,\n\t\t\t\t\tslug: input.slug,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\tif (existing) {\n\t\t\tthrow new Error(\"A blog post with this slug already exists\");\n\t\t}\n\t}\n\n\t// Handle publish state change\n\tlet publishedAt = input.publishedAt;\n\tif (input.isPublished !== undefined) {\n\t\tif (input.isPublished && !post.isPublished) {\n\t\t\t// Publishing for the first time\n\t\t\tpublishedAt = publishedAt ?? new Date();\n\t\t} else if (!input.isPublished) {\n\t\t\t// Unpublishing\n\t\t\tpublishedAt = null;\n\t\t}\n\t}\n\n\tconst updated = await db.blogPost.update({\n\t\twhere: { id },\n\t\tdata: {\n\t\t\tslug: input.slug,\n\t\t\tfeaturedImage: input.featuredImage,\n\t\t\tauthor: input.author,\n\t\t\tisPublished: input.isPublished,\n\t\t\tpublishedAt,\n\t\t\t...(input.translations && {\n\t\t\t\ttranslations: {\n\t\t\t\t\tdeleteMany: {},\n\t\t\t\t\tcreate: input.translations.map((t) => ({\n\t\t\t\t\t\tlocaleId: t.localeId,\n\t\t\t\t\t\ttitle: t.title,\n\t\t\t\t\t\texcerpt: t.excerpt,\n\t\t\t\t\t\tcontent: t.content,\n\t\t\t\t\t})),\n\t\t\t\t},\n\t\t\t}),\n\t\t},\n\t\tinclude: {\n\t\t\ttranslations: true,\n\t\t},\n\t});\n\n\treturn updated;\n}\n\nexport async function deleteBlogPost(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\tawait db.blogPost.delete({\n\t\twhere: { id },\n\t});\n\n\treturn { success: true };\n}\n\nexport async function toggleBlogPostPublished(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\tconst isPublished = !post.isPublished;\n\tconst publishedAt = isPublished\n\t\t? post.publishedAt ?? new Date()\n\t\t: post.publishedAt;\n\n\tconst updated = await db.blogPost.update({\n\t\twhere: { id },\n\t\tdata: {\n\t\t\tisPublished,\n\t\t\tpublishedAt,\n\t\t},\n\t});\n\n\treturn updated;\n}\n\nexport async function getBlogStats() {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst [total, published, drafts] = await Promise.all([\n\t\tdb.blogPost.count({ where: { tenantId } }),\n\t\tdb.blogPost.count({ where: { tenantId, isPublished: true } }),\n\t\tdb.blogPost.count({ where: { tenantId, isPublished: false } }),\n\t]);\n\n\t// Get recent posts (last 7 days)\n\tconst weekAgo = new Date();\n\tweekAgo.setDate(weekAgo.getDate() - 7);\n\n\tconst recent = await db.blogPost.count({\n\t\twhere: {\n\t\t\ttenantId,\n\t\t\tcreatedAt: { gte: weekAgo },\n\t\t},\n\t});\n\n\treturn {\n\t\ttotal,\n\t\tpublished,\n\t\tdrafts,\n\t\trecent,\n\t};\n}\n"],"names":[],"mappings":";;;;;;;MAmSsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,gDAAA"}},
    {"offset": {"line": 351, "column": 0}, "map": {"version":3,"sources":["file:///Users/bobkata/Projects/boostcart/apps/platform/src/server/api/internal/blog.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/server/auth\";\nimport { db } from \"@/server/db\";\nimport { requireAdminTenant } from \"@/server/tenant\";\n\nasync function requireStoreAccess() {\n\tconst session = await auth();\n\tif (!session?.user?.id) {\n\t\tthrow new Error(\"Unauthorized\");\n\t}\n\n\tconst tenant = await requireAdminTenant();\n\n\tconst staffRecord = await db.tenantStaff.findFirst({\n\t\twhere: {\n\t\t\tuserId: session.user.id,\n\t\t\ttenantId: tenant.id,\n\t\t},\n\t});\n\n\tif (!staffRecord) {\n\t\tthrow new Error(\"Forbidden: No access to this store\");\n\t}\n\n\treturn {\n\t\tuserId: session.user.id,\n\t\ttenantId: tenant.id,\n\t\trole: staffRecord.role,\n\t};\n}\n\nexport async function getBlogPosts() {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst posts = await db.blogPost.findMany({\n\t\twhere: { tenantId },\n\t\tinclude: {\n\t\t\ttranslations: {\n\t\t\t\tinclude: {\n\t\t\t\t\tlocale: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\torderBy: { createdAt: \"desc\" },\n\t});\n\n\treturn posts.map((post) => ({\n\t\tid: post.id,\n\t\tslug: post.slug,\n\t\tfeaturedImage: post.featuredImage,\n\t\tauthor: post.author,\n\t\tisPublished: post.isPublished,\n\t\tpublishedAt: post.publishedAt,\n\t\ttitle: post.translations[0]?.title ?? post.slug,\n\t\texcerpt: post.translations[0]?.excerpt ?? \"\",\n\t\tcontent: post.translations[0]?.content ?? \"\",\n\t\ttranslations: post.translations.map((t) => ({\n\t\t\tlocaleId: t.localeId,\n\t\t\tlocaleCode: t.locale.code,\n\t\t\tlocaleName: t.locale.name,\n\t\t\ttitle: t.title,\n\t\t\texcerpt: t.excerpt,\n\t\t\tcontent: t.content,\n\t\t})),\n\t\tcreatedAt: post.createdAt,\n\t\tupdatedAt: post.updatedAt,\n\t}));\n}\n\nexport async function getBlogPost(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t\tinclude: {\n\t\t\ttranslations: {\n\t\t\t\tinclude: {\n\t\t\t\t\tlocale: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found\");\n\t}\n\n\treturn {\n\t\tid: post.id,\n\t\tslug: post.slug,\n\t\tfeaturedImage: post.featuredImage,\n\t\tauthor: post.author,\n\t\tisPublished: post.isPublished,\n\t\tpublishedAt: post.publishedAt,\n\t\ttranslations: post.translations.map((t) => ({\n\t\t\tid: t.id,\n\t\t\tlocaleId: t.localeId,\n\t\t\tlocaleCode: t.locale.code,\n\t\t\tlocaleName: t.locale.name,\n\t\t\ttitle: t.title,\n\t\t\texcerpt: t.excerpt,\n\t\t\tcontent: t.content,\n\t\t})),\n\t\tcreatedAt: post.createdAt,\n\t\tupdatedAt: post.updatedAt,\n\t};\n}\n\nexport interface CreateBlogPostInput {\n\tslug: string;\n\tfeaturedImage?: string;\n\tauthor?: string;\n\tisPublished?: boolean;\n\tpublishedAt?: Date;\n\ttranslations: {\n\t\tlocaleId: string;\n\t\ttitle: string;\n\t\texcerpt?: string;\n\t\tcontent: string;\n\t}[];\n}\n\nexport async function createBlogPost(input: CreateBlogPostInput) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\t// Check for duplicate slug\n\tconst existing = await db.blogPost.findUnique({\n\t\twhere: {\n\t\t\ttenantId_slug: {\n\t\t\t\ttenantId,\n\t\t\t\tslug: input.slug,\n\t\t\t},\n\t\t},\n\t});\n\n\tif (existing) {\n\t\tthrow new Error(\"A blog post with this slug already exists\");\n\t}\n\n\tconst post = await db.blogPost.create({\n\t\tdata: {\n\t\t\tslug: input.slug,\n\t\t\tfeaturedImage: input.featuredImage,\n\t\t\tauthor: input.author,\n\t\t\tisPublished: input.isPublished ?? false,\n\t\t\tpublishedAt: input.isPublished ? (input.publishedAt ?? new Date()) : null,\n\t\t\ttenantId,\n\t\t\ttranslations: {\n\t\t\t\tcreate: input.translations.map((t) => ({\n\t\t\t\t\tlocaleId: t.localeId,\n\t\t\t\t\ttitle: t.title,\n\t\t\t\t\texcerpt: t.excerpt,\n\t\t\t\t\tcontent: t.content,\n\t\t\t\t})),\n\t\t\t},\n\t\t},\n\t\tinclude: {\n\t\t\ttranslations: true,\n\t\t},\n\t});\n\n\treturn post;\n}\n\nexport interface UpdateBlogPostInput {\n\tslug?: string;\n\tfeaturedImage?: string | null;\n\tauthor?: string;\n\tisPublished?: boolean;\n\tpublishedAt?: Date | null;\n\ttranslations?: {\n\t\tlocaleId: string;\n\t\ttitle: string;\n\t\texcerpt?: string;\n\t\tcontent: string;\n\t}[];\n}\n\nexport async function updateBlogPost(id: string, input: UpdateBlogPostInput) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\t// Check for duplicate slug if changing\n\tif (input.slug && input.slug !== post.slug) {\n\t\tconst existing = await db.blogPost.findUnique({\n\t\t\twhere: {\n\t\t\t\ttenantId_slug: {\n\t\t\t\t\ttenantId,\n\t\t\t\t\tslug: input.slug,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\tif (existing) {\n\t\t\tthrow new Error(\"A blog post with this slug already exists\");\n\t\t}\n\t}\n\n\t// Handle publish state change\n\tlet publishedAt = input.publishedAt;\n\tif (input.isPublished !== undefined) {\n\t\tif (input.isPublished && !post.isPublished) {\n\t\t\t// Publishing for the first time\n\t\t\tpublishedAt = publishedAt ?? new Date();\n\t\t} else if (!input.isPublished) {\n\t\t\t// Unpublishing\n\t\t\tpublishedAt = null;\n\t\t}\n\t}\n\n\tconst updated = await db.blogPost.update({\n\t\twhere: { id },\n\t\tdata: {\n\t\t\tslug: input.slug,\n\t\t\tfeaturedImage: input.featuredImage,\n\t\t\tauthor: input.author,\n\t\t\tisPublished: input.isPublished,\n\t\t\tpublishedAt,\n\t\t\t...(input.translations && {\n\t\t\t\ttranslations: {\n\t\t\t\t\tdeleteMany: {},\n\t\t\t\t\tcreate: input.translations.map((t) => ({\n\t\t\t\t\t\tlocaleId: t.localeId,\n\t\t\t\t\t\ttitle: t.title,\n\t\t\t\t\t\texcerpt: t.excerpt,\n\t\t\t\t\t\tcontent: t.content,\n\t\t\t\t\t})),\n\t\t\t\t},\n\t\t\t}),\n\t\t},\n\t\tinclude: {\n\t\t\ttranslations: true,\n\t\t},\n\t});\n\n\treturn updated;\n}\n\nexport async function deleteBlogPost(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\tawait db.blogPost.delete({\n\t\twhere: { id },\n\t});\n\n\treturn { success: true };\n}\n\nexport async function toggleBlogPostPublished(id: string) {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst post = await db.blogPost.findFirst({\n\t\twhere: { id, tenantId },\n\t});\n\n\tif (!post) {\n\t\tthrow new Error(\"Blog post not found or access denied\");\n\t}\n\n\tconst isPublished = !post.isPublished;\n\tconst publishedAt = isPublished\n\t\t? post.publishedAt ?? new Date()\n\t\t: post.publishedAt;\n\n\tconst updated = await db.blogPost.update({\n\t\twhere: { id },\n\t\tdata: {\n\t\t\tisPublished,\n\t\t\tpublishedAt,\n\t\t},\n\t});\n\n\treturn updated;\n}\n\nexport async function getBlogStats() {\n\tconst { tenantId } = await requireStoreAccess();\n\n\tconst [total, published, drafts] = await Promise.all([\n\t\tdb.blogPost.count({ where: { tenantId } }),\n\t\tdb.blogPost.count({ where: { tenantId, isPublished: true } }),\n\t\tdb.blogPost.count({ where: { tenantId, isPublished: false } }),\n\t]);\n\n\t// Get recent posts (last 7 days)\n\tconst weekAgo = new Date();\n\tweekAgo.setDate(weekAgo.getDate() - 7);\n\n\tconst recent = await db.blogPost.count({\n\t\twhere: {\n\t\t\ttenantId,\n\t\t\tcreatedAt: { gte: weekAgo },\n\t\t},\n\t});\n\n\treturn {\n\t\ttotal,\n\t\tpublished,\n\t\tdrafts,\n\t\trecent,\n\t};\n}\n"],"names":[],"mappings":";;;;;;;MAwQsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA,2DAAA"}},
    {"offset": {"line": 371, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/calendar.js","sources":["file:///Users/bobkata/Projects/boostcart/node_modules/lucide-react/src/icons/calendar.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M8 2v4', key: '1cmpym' }],\n  ['path', { d: 'M16 2v4', key: '4m81vk' }],\n  ['rect', { width: '18', height: '18', x: '3', y: '4', rx: '2', key: '1hopcy' }],\n  ['path', { d: 'M3 10h18', key: '8toen8' }],\n];\n\n/**\n * @component @name Calendar\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNOCAydjQiIC8+CiAgPHBhdGggZD0iTTE2IDJ2NCIgLz4KICA8cmVjdCB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHg9IjMiIHk9IjQiIHJ4PSIyIiAvPgogIDxwYXRoIGQ9Ik0zIDEwaDE4IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/calendar\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Calendar = createLucideIcon('calendar', __iconNode);\n\nexport default Calendar;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAU,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACvC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAW,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACxC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAO,CAAA,CAAA,CAAA;YAAM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA,CAAA,CAAA,CAAA,CAAA;YAAM,CAAA,CAAA,CAAG,CAAA,CAAA,CAAA,CAAA;YAAK,GAAG,CAAA,CAAA,CAAA,CAAA;YAAK,CAAA,CAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA;YAAK,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IAC9E;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CAC3C;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,QAAA,CAAA,CAAA,KAAW,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAY,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 434, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/eye.js","sources":["file:///Users/bobkata/Projects/boostcart/node_modules/lucide-react/src/icons/eye.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  [\n    'path',\n    {\n      d: 'M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0',\n      key: '1nclc0',\n    },\n  ],\n  ['circle', { cx: '12', cy: '12', r: '3', key: '1v7zrd' }],\n];\n\n/**\n * @component @name Eye\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMi4wNjIgMTIuMzQ4YTEgMSAwIDAgMSAwLS42OTYgMTAuNzUgMTAuNzUgMCAwIDEgMTkuODc2IDAgMSAxIDAgMCAxIDAgLjY5NiAxMC43NSAxMC43NSAwIDAgMS0xOS44NzYgMCIgLz4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIzIiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/eye\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Eye = createLucideIcon('eye', __iconNode);\n\nexport default Eye;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QACE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QACA;YACE,CAAA,EAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YACH,GAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA;KAET;IACA;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAU;YAAE,CAAA,CAAA,CAAA,CAAI,IAAA,CAAA;YAAM,CAAA,CAAA,EAAI,CAAA,CAAA,CAAA,CAAA,CAAA;YAAM,CAAA,CAAA,CAAG,CAAA,CAAA,CAAA;YAAK,CAAA,CAAA,CAAA,CAAA,CAAK,QAAA;QAAA,CAAU;KAAA;CAC1D;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,GAAA,CAAA,CAAA,KAAM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,EAAO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 481, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/pencil.js","sources":["file:///Users/bobkata/Projects/boostcart/node_modules/lucide-react/src/icons/pencil.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  [\n    'path',\n    {\n      d: 'M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z',\n      key: '1a8usu',\n    },\n  ],\n  ['path', { d: 'm15 5 4 4', key: '1mk7zo' }],\n];\n\n/**\n * @component @name Pencil\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjEuMTc0IDYuODEyYTEgMSAwIDAgMC0zLjk4Ni0zLjk4N0wzLjg0MiAxNi4xNzRhMiAyIDAgMCAwLS41LjgzbC0xLjMyMSA0LjM1MmEuNS41IDAgMCAwIC42MjMuNjIybDQuMzUzLTEuMzJhMiAyIDAgMCAwIC44My0uNDk3eiIgLz4KICA8cGF0aCBkPSJtMTUgNSA0IDQiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/pencil\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Pencil = createLucideIcon('pencil', __iconNode);\n\nexport default Pencil;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QACE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QACA;YACE,CAAA,EAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YACH,GAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA;KAET;IACA;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAa,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CAC5C;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,MAAA,CAAA,CAAA,KAAS,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAU,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 526, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/plus.js","sources":["file:///Users/bobkata/Projects/boostcart/node_modules/lucide-react/src/icons/plus.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M5 12h14', key: '1ays0h' }],\n  ['path', { d: 'M12 5v14', key: 's699le' }],\n];\n\n/**\n * @component @name Plus\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNNSAxMmgxNCIgLz4KICA8cGF0aCBkPSJNMTIgNXYxNCIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/plus\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Plus = createLucideIcon('plus', __iconNode);\n\nexport default Plus;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CAC3C;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,IAAA,CAAA,CAAA,KAAO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAQ,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/trash-2.js","sources":["file:///Users/bobkata/Projects/boostcart/node_modules/lucide-react/src/icons/trash-2.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M10 11v6', key: 'nco0om' }],\n  ['path', { d: 'M14 11v6', key: 'outv1u' }],\n  ['path', { d: 'M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6', key: 'miytrc' }],\n  ['path', { d: 'M3 6h18', key: 'd0wm0j' }],\n  ['path', { d: 'M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2', key: 'e791ji' }],\n];\n\n/**\n * @component @name Trash2\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTAgMTF2NiIgLz4KICA8cGF0aCBkPSJNMTQgMTF2NiIgLz4KICA8cGF0aCBkPSJNMTkgNnYxNGEyIDIgMCAwIDEtMiAySDdhMiAyIDAgMCAxLTItMlY2IiAvPgogIDxwYXRoIGQ9Ik0zIDZoMTgiIC8+CiAgPHBhdGggZD0iTTggNlY0YTIgMiAwIDAgMSAyLTJoNGEyIDIgMCAwIDEgMiAydjIiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/trash-2\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Trash2 = createLucideIcon('trash-2', __iconNode);\n\nexport default Trash2;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAA4C,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzE;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAW,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACxC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAA0C,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CACzE;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,MAAA,CAAA,CAAA,KAAS,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAW,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}}]
}