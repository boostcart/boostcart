
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Tenant: 'Tenant',
  TenantStaff: 'TenantStaff',
  TenantDomain: 'TenantDomain',
  Customer: 'Customer',
  CustomerAddress: 'CustomerAddress',
  CustomerSession: 'CustomerSession',
  User: 'User',
  Account: 'Account',
  Session: 'Session',
  Verification: 'Verification',
  EmailVerificationToken: 'EmailVerificationToken',
  PasswordResetToken: 'PasswordResetToken',
  Locale: 'Locale',
  Currency: 'Currency',
  Brand: 'Brand',
  BrandTranslation: 'BrandTranslation',
  Category: 'Category',
  CategoryTranslation: 'CategoryTranslation',
  Product: 'Product',
  ProductTranslation: 'ProductTranslation',
  ProductMedia: 'ProductMedia',
  ProductSpecification: 'ProductSpecification',
  ProductSpecificationTranslation: 'ProductSpecificationTranslation',
  ProductShippingInfo: 'ProductShippingInfo',
  ProductDownload: 'ProductDownload',
  Filter: 'Filter',
  FilterAttribute: 'FilterAttribute',
  FilterAttributeTranslation: 'FilterAttributeTranslation',
  ProductFilter: 'ProductFilter',
  CategoryFilter: 'CategoryFilter',
  ProductVariant: 'ProductVariant',
  VariantOptionMeta: 'VariantOptionMeta',
  ProductCustomizationOption: 'ProductCustomizationOption',
  ProductCustomizationOptionTranslation: 'ProductCustomizationOptionTranslation',
  ProductCustomizationOptionValue: 'ProductCustomizationOptionValue',
  ProductCustomizationOptionValueTranslation: 'ProductCustomizationOptionValueTranslation',
  Discount: 'Discount',
  DiscountProduct: 'DiscountProduct',
  DiscountCategory: 'DiscountCategory',
  DiscountBrand: 'DiscountBrand',
  PromoCode: 'PromoCode',
  PromoCodeProduct: 'PromoCodeProduct',
  PromoCodeCategory: 'PromoCodeCategory',
  PromoCodeBrand: 'PromoCodeBrand',
  GiftCard: 'GiftCard',
  Cart: 'Cart',
  CartItem: 'CartItem',
  Order: 'Order',
  OrderItem: 'OrderItem',
  OrderHistory: 'OrderHistory',
  ShippingMethod: 'ShippingMethod',
  PaymentMethod: 'PaymentMethod',
  UserAddress: 'UserAddress',
  WishlistItem: 'WishlistItem',
  Review: 'Review',
  Media: 'Media',
  BlogPost: 'BlogPost',
  BlogPostTranslation: 'BlogPostTranslation',
  Page: 'Page',
  PageTranslation: 'PageTranslation',
  Collection: 'Collection',
  CollectionTranslation: 'CollectionTranslation',
  CollectionProduct: 'CollectionProduct'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "tenant" | "tenantStaff" | "tenantDomain" | "customer" | "customerAddress" | "customerSession" | "user" | "account" | "session" | "verification" | "emailVerificationToken" | "passwordResetToken" | "locale" | "currency" | "brand" | "brandTranslation" | "category" | "categoryTranslation" | "product" | "productTranslation" | "productMedia" | "productSpecification" | "productSpecificationTranslation" | "productShippingInfo" | "productDownload" | "filter" | "filterAttribute" | "filterAttributeTranslation" | "productFilter" | "categoryFilter" | "productVariant" | "variantOptionMeta" | "productCustomizationOption" | "productCustomizationOptionTranslation" | "productCustomizationOptionValue" | "productCustomizationOptionValueTranslation" | "discount" | "discountProduct" | "discountCategory" | "discountBrand" | "promoCode" | "promoCodeProduct" | "promoCodeCategory" | "promoCodeBrand" | "giftCard" | "cart" | "cartItem" | "order" | "orderItem" | "orderHistory" | "shippingMethod" | "paymentMethod" | "userAddress" | "wishlistItem" | "review" | "media" | "blogPost" | "blogPostTranslation" | "page" | "pageTranslation" | "collection" | "collectionTranslation" | "collectionProduct"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Tenant: {
      payload: Prisma.$TenantPayload<ExtArgs>
      fields: Prisma.TenantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findFirst: {
          args: Prisma.TenantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findMany: {
          args: Prisma.TenantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        create: {
          args: Prisma.TenantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        createMany: {
          args: Prisma.TenantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        delete: {
          args: Prisma.TenantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        update: {
          args: Prisma.TenantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        deleteMany: {
          args: Prisma.TenantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        upsert: {
          args: Prisma.TenantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        aggregate: {
          args: Prisma.TenantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenant>
        }
        groupBy: {
          args: Prisma.TenantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantCountAggregateOutputType> | number
        }
      }
    }
    TenantStaff: {
      payload: Prisma.$TenantStaffPayload<ExtArgs>
      fields: Prisma.TenantStaffFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantStaffFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantStaffPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantStaffFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantStaffPayload>
        }
        findFirst: {
          args: Prisma.TenantStaffFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantStaffPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantStaffFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantStaffPayload>
        }
        findMany: {
          args: Prisma.TenantStaffFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantStaffPayload>[]
        }
        create: {
          args: Prisma.TenantStaffCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantStaffPayload>
        }
        createMany: {
          args: Prisma.TenantStaffCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantStaffCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantStaffPayload>[]
        }
        delete: {
          args: Prisma.TenantStaffDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantStaffPayload>
        }
        update: {
          args: Prisma.TenantStaffUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantStaffPayload>
        }
        deleteMany: {
          args: Prisma.TenantStaffDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantStaffUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantStaffUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantStaffPayload>[]
        }
        upsert: {
          args: Prisma.TenantStaffUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantStaffPayload>
        }
        aggregate: {
          args: Prisma.TenantStaffAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantStaff>
        }
        groupBy: {
          args: Prisma.TenantStaffGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantStaffGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantStaffCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantStaffCountAggregateOutputType> | number
        }
      }
    }
    TenantDomain: {
      payload: Prisma.$TenantDomainPayload<ExtArgs>
      fields: Prisma.TenantDomainFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantDomainFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantDomainFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        findFirst: {
          args: Prisma.TenantDomainFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantDomainFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        findMany: {
          args: Prisma.TenantDomainFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>[]
        }
        create: {
          args: Prisma.TenantDomainCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        createMany: {
          args: Prisma.TenantDomainCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantDomainCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>[]
        }
        delete: {
          args: Prisma.TenantDomainDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        update: {
          args: Prisma.TenantDomainUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        deleteMany: {
          args: Prisma.TenantDomainDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantDomainUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantDomainUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>[]
        }
        upsert: {
          args: Prisma.TenantDomainUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        aggregate: {
          args: Prisma.TenantDomainAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantDomain>
        }
        groupBy: {
          args: Prisma.TenantDomainGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantDomainGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantDomainCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantDomainCountAggregateOutputType> | number
        }
      }
    }
    Customer: {
      payload: Prisma.$CustomerPayload<ExtArgs>
      fields: Prisma.CustomerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findFirst: {
          args: Prisma.CustomerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findMany: {
          args: Prisma.CustomerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        create: {
          args: Prisma.CustomerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        createMany: {
          args: Prisma.CustomerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        delete: {
          args: Prisma.CustomerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        update: {
          args: Prisma.CustomerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        deleteMany: {
          args: Prisma.CustomerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        upsert: {
          args: Prisma.CustomerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        aggregate: {
          args: Prisma.CustomerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomer>
        }
        groupBy: {
          args: Prisma.CustomerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerCountAggregateOutputType> | number
        }
      }
    }
    CustomerAddress: {
      payload: Prisma.$CustomerAddressPayload<ExtArgs>
      fields: Prisma.CustomerAddressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerAddressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerAddressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        findFirst: {
          args: Prisma.CustomerAddressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerAddressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        findMany: {
          args: Prisma.CustomerAddressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
        }
        create: {
          args: Prisma.CustomerAddressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        createMany: {
          args: Prisma.CustomerAddressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerAddressCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
        }
        delete: {
          args: Prisma.CustomerAddressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        update: {
          args: Prisma.CustomerAddressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        deleteMany: {
          args: Prisma.CustomerAddressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerAddressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerAddressUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
        }
        upsert: {
          args: Prisma.CustomerAddressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        aggregate: {
          args: Prisma.CustomerAddressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerAddress>
        }
        groupBy: {
          args: Prisma.CustomerAddressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerAddressGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerAddressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerAddressCountAggregateOutputType> | number
        }
      }
    }
    CustomerSession: {
      payload: Prisma.$CustomerSessionPayload<ExtArgs>
      fields: Prisma.CustomerSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerSessionPayload>
        }
        findFirst: {
          args: Prisma.CustomerSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerSessionPayload>
        }
        findMany: {
          args: Prisma.CustomerSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerSessionPayload>[]
        }
        create: {
          args: Prisma.CustomerSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerSessionPayload>
        }
        createMany: {
          args: Prisma.CustomerSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerSessionPayload>[]
        }
        delete: {
          args: Prisma.CustomerSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerSessionPayload>
        }
        update: {
          args: Prisma.CustomerSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerSessionPayload>
        }
        deleteMany: {
          args: Prisma.CustomerSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerSessionPayload>[]
        }
        upsert: {
          args: Prisma.CustomerSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerSessionPayload>
        }
        aggregate: {
          args: Prisma.CustomerSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerSession>
        }
        groupBy: {
          args: Prisma.CustomerSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerSessionCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Account: {
      payload: Prisma.$AccountPayload<ExtArgs>
      fields: Prisma.AccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findFirst: {
          args: Prisma.AccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findMany: {
          args: Prisma.AccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        create: {
          args: Prisma.AccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        createMany: {
          args: Prisma.AccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        delete: {
          args: Prisma.AccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        update: {
          args: Prisma.AccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        deleteMany: {
          args: Prisma.AccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        upsert: {
          args: Prisma.AccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        aggregate: {
          args: Prisma.AccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>
        }
        groupBy: {
          args: Prisma.AccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType> | number
        }
      }
    }
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>
      fields: Prisma.SessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
    Verification: {
      payload: Prisma.$VerificationPayload<ExtArgs>
      fields: Prisma.VerificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VerificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>
        }
        findFirst: {
          args: Prisma.VerificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>
        }
        findMany: {
          args: Prisma.VerificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[]
        }
        create: {
          args: Prisma.VerificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>
        }
        createMany: {
          args: Prisma.VerificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[]
        }
        delete: {
          args: Prisma.VerificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>
        }
        update: {
          args: Prisma.VerificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>
        }
        deleteMany: {
          args: Prisma.VerificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VerificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[]
        }
        upsert: {
          args: Prisma.VerificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>
        }
        aggregate: {
          args: Prisma.VerificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerification>
        }
        groupBy: {
          args: Prisma.VerificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.VerificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationCountAggregateOutputType> | number
        }
      }
    }
    EmailVerificationToken: {
      payload: Prisma.$EmailVerificationTokenPayload<ExtArgs>
      fields: Prisma.EmailVerificationTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmailVerificationTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        findFirst: {
          args: Prisma.EmailVerificationTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        findMany: {
          args: Prisma.EmailVerificationTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
        }
        create: {
          args: Prisma.EmailVerificationTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        createMany: {
          args: Prisma.EmailVerificationTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
        }
        delete: {
          args: Prisma.EmailVerificationTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        update: {
          args: Prisma.EmailVerificationTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        deleteMany: {
          args: Prisma.EmailVerificationTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmailVerificationTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
        }
        upsert: {
          args: Prisma.EmailVerificationTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        aggregate: {
          args: Prisma.EmailVerificationTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmailVerificationToken>
        }
        groupBy: {
          args: Prisma.EmailVerificationTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailVerificationTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmailVerificationTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailVerificationTokenCountAggregateOutputType> | number
        }
      }
    }
    PasswordResetToken: {
      payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
      fields: Prisma.PasswordResetTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        findFirst: {
          args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        findMany: {
          args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
        }
        create: {
          args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        createMany: {
          args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
        }
        delete: {
          args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        update: {
          args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        deleteMany: {
          args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
        }
        upsert: {
          args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        aggregate: {
          args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePasswordResetToken>
        }
        groupBy: {
          args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PasswordResetTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PasswordResetTokenCountAggregateOutputType> | number
        }
      }
    }
    Locale: {
      payload: Prisma.$LocalePayload<ExtArgs>
      fields: Prisma.LocaleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LocaleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocalePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LocaleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocalePayload>
        }
        findFirst: {
          args: Prisma.LocaleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocalePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LocaleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocalePayload>
        }
        findMany: {
          args: Prisma.LocaleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocalePayload>[]
        }
        create: {
          args: Prisma.LocaleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocalePayload>
        }
        createMany: {
          args: Prisma.LocaleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LocaleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocalePayload>[]
        }
        delete: {
          args: Prisma.LocaleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocalePayload>
        }
        update: {
          args: Prisma.LocaleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocalePayload>
        }
        deleteMany: {
          args: Prisma.LocaleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LocaleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LocaleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocalePayload>[]
        }
        upsert: {
          args: Prisma.LocaleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocalePayload>
        }
        aggregate: {
          args: Prisma.LocaleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLocale>
        }
        groupBy: {
          args: Prisma.LocaleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LocaleGroupByOutputType>[]
        }
        count: {
          args: Prisma.LocaleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LocaleCountAggregateOutputType> | number
        }
      }
    }
    Currency: {
      payload: Prisma.$CurrencyPayload<ExtArgs>
      fields: Prisma.CurrencyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        findFirst: {
          args: Prisma.CurrencyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        findMany: {
          args: Prisma.CurrencyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
        }
        create: {
          args: Prisma.CurrencyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        createMany: {
          args: Prisma.CurrencyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
        }
        delete: {
          args: Prisma.CurrencyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        update: {
          args: Prisma.CurrencyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        deleteMany: {
          args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
        }
        upsert: {
          args: Prisma.CurrencyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        aggregate: {
          args: Prisma.CurrencyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCurrency>
        }
        groupBy: {
          args: Prisma.CurrencyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CurrencyGroupByOutputType>[]
        }
        count: {
          args: Prisma.CurrencyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CurrencyCountAggregateOutputType> | number
        }
      }
    }
    Brand: {
      payload: Prisma.$BrandPayload<ExtArgs>
      fields: Prisma.BrandFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BrandFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandPayload>
        }
        findFirst: {
          args: Prisma.BrandFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandPayload>
        }
        findMany: {
          args: Prisma.BrandFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandPayload>[]
        }
        create: {
          args: Prisma.BrandCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandPayload>
        }
        createMany: {
          args: Prisma.BrandCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandPayload>[]
        }
        delete: {
          args: Prisma.BrandDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandPayload>
        }
        update: {
          args: Prisma.BrandUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandPayload>
        }
        deleteMany: {
          args: Prisma.BrandDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BrandUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BrandUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandPayload>[]
        }
        upsert: {
          args: Prisma.BrandUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandPayload>
        }
        aggregate: {
          args: Prisma.BrandAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBrand>
        }
        groupBy: {
          args: Prisma.BrandGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BrandGroupByOutputType>[]
        }
        count: {
          args: Prisma.BrandCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BrandCountAggregateOutputType> | number
        }
      }
    }
    BrandTranslation: {
      payload: Prisma.$BrandTranslationPayload<ExtArgs>
      fields: Prisma.BrandTranslationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BrandTranslationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandTranslationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BrandTranslationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandTranslationPayload>
        }
        findFirst: {
          args: Prisma.BrandTranslationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandTranslationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BrandTranslationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandTranslationPayload>
        }
        findMany: {
          args: Prisma.BrandTranslationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandTranslationPayload>[]
        }
        create: {
          args: Prisma.BrandTranslationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandTranslationPayload>
        }
        createMany: {
          args: Prisma.BrandTranslationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BrandTranslationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandTranslationPayload>[]
        }
        delete: {
          args: Prisma.BrandTranslationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandTranslationPayload>
        }
        update: {
          args: Prisma.BrandTranslationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandTranslationPayload>
        }
        deleteMany: {
          args: Prisma.BrandTranslationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BrandTranslationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BrandTranslationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandTranslationPayload>[]
        }
        upsert: {
          args: Prisma.BrandTranslationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BrandTranslationPayload>
        }
        aggregate: {
          args: Prisma.BrandTranslationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBrandTranslation>
        }
        groupBy: {
          args: Prisma.BrandTranslationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BrandTranslationGroupByOutputType>[]
        }
        count: {
          args: Prisma.BrandTranslationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BrandTranslationCountAggregateOutputType> | number
        }
      }
    }
    Category: {
      payload: Prisma.$CategoryPayload<ExtArgs>
      fields: Prisma.CategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        findFirst: {
          args: Prisma.CategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        findMany: {
          args: Prisma.CategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        create: {
          args: Prisma.CategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        createMany: {
          args: Prisma.CategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        delete: {
          args: Prisma.CategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        update: {
          args: Prisma.CategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        deleteMany: {
          args: Prisma.CategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        upsert: {
          args: Prisma.CategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        aggregate: {
          args: Prisma.CategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategory>
        }
        groupBy: {
          args: Prisma.CategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryCountAggregateOutputType> | number
        }
      }
    }
    CategoryTranslation: {
      payload: Prisma.$CategoryTranslationPayload<ExtArgs>
      fields: Prisma.CategoryTranslationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CategoryTranslationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryTranslationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CategoryTranslationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
        }
        findFirst: {
          args: Prisma.CategoryTranslationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryTranslationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CategoryTranslationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
        }
        findMany: {
          args: Prisma.CategoryTranslationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>[]
        }
        create: {
          args: Prisma.CategoryTranslationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
        }
        createMany: {
          args: Prisma.CategoryTranslationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CategoryTranslationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>[]
        }
        delete: {
          args: Prisma.CategoryTranslationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
        }
        update: {
          args: Prisma.CategoryTranslationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
        }
        deleteMany: {
          args: Prisma.CategoryTranslationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CategoryTranslationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CategoryTranslationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>[]
        }
        upsert: {
          args: Prisma.CategoryTranslationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryTranslationPayload>
        }
        aggregate: {
          args: Prisma.CategoryTranslationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategoryTranslation>
        }
        groupBy: {
          args: Prisma.CategoryTranslationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryTranslationGroupByOutputType>[]
        }
        count: {
          args: Prisma.CategoryTranslationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryTranslationCountAggregateOutputType> | number
        }
      }
    }
    Product: {
      payload: Prisma.$ProductPayload<ExtArgs>
      fields: Prisma.ProductFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        findFirst: {
          args: Prisma.ProductFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        findMany: {
          args: Prisma.ProductFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        create: {
          args: Prisma.ProductCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        createMany: {
          args: Prisma.ProductCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        delete: {
          args: Prisma.ProductDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        update: {
          args: Prisma.ProductUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        deleteMany: {
          args: Prisma.ProductDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
        }
        upsert: {
          args: Prisma.ProductUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
        }
        aggregate: {
          args: Prisma.ProductAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProduct>
        }
        groupBy: {
          args: Prisma.ProductGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCountAggregateOutputType> | number
        }
      }
    }
    ProductTranslation: {
      payload: Prisma.$ProductTranslationPayload<ExtArgs>
      fields: Prisma.ProductTranslationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductTranslationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTranslationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductTranslationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
        }
        findFirst: {
          args: Prisma.ProductTranslationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTranslationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductTranslationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
        }
        findMany: {
          args: Prisma.ProductTranslationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTranslationPayload>[]
        }
        create: {
          args: Prisma.ProductTranslationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
        }
        createMany: {
          args: Prisma.ProductTranslationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductTranslationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTranslationPayload>[]
        }
        delete: {
          args: Prisma.ProductTranslationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
        }
        update: {
          args: Prisma.ProductTranslationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
        }
        deleteMany: {
          args: Prisma.ProductTranslationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductTranslationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductTranslationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTranslationPayload>[]
        }
        upsert: {
          args: Prisma.ProductTranslationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
        }
        aggregate: {
          args: Prisma.ProductTranslationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductTranslation>
        }
        groupBy: {
          args: Prisma.ProductTranslationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductTranslationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductTranslationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductTranslationCountAggregateOutputType> | number
        }
      }
    }
    ProductMedia: {
      payload: Prisma.$ProductMediaPayload<ExtArgs>
      fields: Prisma.ProductMediaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductMediaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductMediaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        findFirst: {
          args: Prisma.ProductMediaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductMediaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        findMany: {
          args: Prisma.ProductMediaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>[]
        }
        create: {
          args: Prisma.ProductMediaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        createMany: {
          args: Prisma.ProductMediaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductMediaCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>[]
        }
        delete: {
          args: Prisma.ProductMediaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        update: {
          args: Prisma.ProductMediaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        deleteMany: {
          args: Prisma.ProductMediaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductMediaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductMediaUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>[]
        }
        upsert: {
          args: Prisma.ProductMediaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductMediaPayload>
        }
        aggregate: {
          args: Prisma.ProductMediaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductMedia>
        }
        groupBy: {
          args: Prisma.ProductMediaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductMediaGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductMediaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductMediaCountAggregateOutputType> | number
        }
      }
    }
    ProductSpecification: {
      payload: Prisma.$ProductSpecificationPayload<ExtArgs>
      fields: Prisma.ProductSpecificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductSpecificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductSpecificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
        }
        findFirst: {
          args: Prisma.ProductSpecificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductSpecificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
        }
        findMany: {
          args: Prisma.ProductSpecificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>[]
        }
        create: {
          args: Prisma.ProductSpecificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
        }
        createMany: {
          args: Prisma.ProductSpecificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductSpecificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>[]
        }
        delete: {
          args: Prisma.ProductSpecificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
        }
        update: {
          args: Prisma.ProductSpecificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
        }
        deleteMany: {
          args: Prisma.ProductSpecificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductSpecificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductSpecificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>[]
        }
        upsert: {
          args: Prisma.ProductSpecificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
        }
        aggregate: {
          args: Prisma.ProductSpecificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductSpecification>
        }
        groupBy: {
          args: Prisma.ProductSpecificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductSpecificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductSpecificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductSpecificationCountAggregateOutputType> | number
        }
      }
    }
    ProductSpecificationTranslation: {
      payload: Prisma.$ProductSpecificationTranslationPayload<ExtArgs>
      fields: Prisma.ProductSpecificationTranslationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductSpecificationTranslationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationTranslationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductSpecificationTranslationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationTranslationPayload>
        }
        findFirst: {
          args: Prisma.ProductSpecificationTranslationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationTranslationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductSpecificationTranslationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationTranslationPayload>
        }
        findMany: {
          args: Prisma.ProductSpecificationTranslationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationTranslationPayload>[]
        }
        create: {
          args: Prisma.ProductSpecificationTranslationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationTranslationPayload>
        }
        createMany: {
          args: Prisma.ProductSpecificationTranslationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductSpecificationTranslationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationTranslationPayload>[]
        }
        delete: {
          args: Prisma.ProductSpecificationTranslationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationTranslationPayload>
        }
        update: {
          args: Prisma.ProductSpecificationTranslationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationTranslationPayload>
        }
        deleteMany: {
          args: Prisma.ProductSpecificationTranslationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductSpecificationTranslationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductSpecificationTranslationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationTranslationPayload>[]
        }
        upsert: {
          args: Prisma.ProductSpecificationTranslationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductSpecificationTranslationPayload>
        }
        aggregate: {
          args: Prisma.ProductSpecificationTranslationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductSpecificationTranslation>
        }
        groupBy: {
          args: Prisma.ProductSpecificationTranslationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductSpecificationTranslationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductSpecificationTranslationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductSpecificationTranslationCountAggregateOutputType> | number
        }
      }
    }
    ProductShippingInfo: {
      payload: Prisma.$ProductShippingInfoPayload<ExtArgs>
      fields: Prisma.ProductShippingInfoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductShippingInfoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductShippingInfoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductShippingInfoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductShippingInfoPayload>
        }
        findFirst: {
          args: Prisma.ProductShippingInfoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductShippingInfoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductShippingInfoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductShippingInfoPayload>
        }
        findMany: {
          args: Prisma.ProductShippingInfoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductShippingInfoPayload>[]
        }
        create: {
          args: Prisma.ProductShippingInfoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductShippingInfoPayload>
        }
        createMany: {
          args: Prisma.ProductShippingInfoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductShippingInfoCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductShippingInfoPayload>[]
        }
        delete: {
          args: Prisma.ProductShippingInfoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductShippingInfoPayload>
        }
        update: {
          args: Prisma.ProductShippingInfoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductShippingInfoPayload>
        }
        deleteMany: {
          args: Prisma.ProductShippingInfoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductShippingInfoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductShippingInfoUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductShippingInfoPayload>[]
        }
        upsert: {
          args: Prisma.ProductShippingInfoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductShippingInfoPayload>
        }
        aggregate: {
          args: Prisma.ProductShippingInfoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductShippingInfo>
        }
        groupBy: {
          args: Prisma.ProductShippingInfoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductShippingInfoGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductShippingInfoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductShippingInfoCountAggregateOutputType> | number
        }
      }
    }
    ProductDownload: {
      payload: Prisma.$ProductDownloadPayload<ExtArgs>
      fields: Prisma.ProductDownloadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductDownloadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDownloadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductDownloadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDownloadPayload>
        }
        findFirst: {
          args: Prisma.ProductDownloadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDownloadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductDownloadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDownloadPayload>
        }
        findMany: {
          args: Prisma.ProductDownloadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDownloadPayload>[]
        }
        create: {
          args: Prisma.ProductDownloadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDownloadPayload>
        }
        createMany: {
          args: Prisma.ProductDownloadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductDownloadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDownloadPayload>[]
        }
        delete: {
          args: Prisma.ProductDownloadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDownloadPayload>
        }
        update: {
          args: Prisma.ProductDownloadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDownloadPayload>
        }
        deleteMany: {
          args: Prisma.ProductDownloadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductDownloadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductDownloadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDownloadPayload>[]
        }
        upsert: {
          args: Prisma.ProductDownloadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductDownloadPayload>
        }
        aggregate: {
          args: Prisma.ProductDownloadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductDownload>
        }
        groupBy: {
          args: Prisma.ProductDownloadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductDownloadGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductDownloadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductDownloadCountAggregateOutputType> | number
        }
      }
    }
    Filter: {
      payload: Prisma.$FilterPayload<ExtArgs>
      fields: Prisma.FilterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FilterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FilterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPayload>
        }
        findFirst: {
          args: Prisma.FilterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FilterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPayload>
        }
        findMany: {
          args: Prisma.FilterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPayload>[]
        }
        create: {
          args: Prisma.FilterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPayload>
        }
        createMany: {
          args: Prisma.FilterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FilterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPayload>[]
        }
        delete: {
          args: Prisma.FilterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPayload>
        }
        update: {
          args: Prisma.FilterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPayload>
        }
        deleteMany: {
          args: Prisma.FilterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FilterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FilterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPayload>[]
        }
        upsert: {
          args: Prisma.FilterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPayload>
        }
        aggregate: {
          args: Prisma.FilterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFilter>
        }
        groupBy: {
          args: Prisma.FilterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FilterGroupByOutputType>[]
        }
        count: {
          args: Prisma.FilterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FilterCountAggregateOutputType> | number
        }
      }
    }
    FilterAttribute: {
      payload: Prisma.$FilterAttributePayload<ExtArgs>
      fields: Prisma.FilterAttributeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FilterAttributeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FilterAttributeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributePayload>
        }
        findFirst: {
          args: Prisma.FilterAttributeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FilterAttributeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributePayload>
        }
        findMany: {
          args: Prisma.FilterAttributeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributePayload>[]
        }
        create: {
          args: Prisma.FilterAttributeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributePayload>
        }
        createMany: {
          args: Prisma.FilterAttributeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FilterAttributeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributePayload>[]
        }
        delete: {
          args: Prisma.FilterAttributeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributePayload>
        }
        update: {
          args: Prisma.FilterAttributeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributePayload>
        }
        deleteMany: {
          args: Prisma.FilterAttributeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FilterAttributeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FilterAttributeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributePayload>[]
        }
        upsert: {
          args: Prisma.FilterAttributeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributePayload>
        }
        aggregate: {
          args: Prisma.FilterAttributeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFilterAttribute>
        }
        groupBy: {
          args: Prisma.FilterAttributeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FilterAttributeGroupByOutputType>[]
        }
        count: {
          args: Prisma.FilterAttributeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FilterAttributeCountAggregateOutputType> | number
        }
      }
    }
    FilterAttributeTranslation: {
      payload: Prisma.$FilterAttributeTranslationPayload<ExtArgs>
      fields: Prisma.FilterAttributeTranslationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FilterAttributeTranslationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributeTranslationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FilterAttributeTranslationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributeTranslationPayload>
        }
        findFirst: {
          args: Prisma.FilterAttributeTranslationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributeTranslationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FilterAttributeTranslationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributeTranslationPayload>
        }
        findMany: {
          args: Prisma.FilterAttributeTranslationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributeTranslationPayload>[]
        }
        create: {
          args: Prisma.FilterAttributeTranslationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributeTranslationPayload>
        }
        createMany: {
          args: Prisma.FilterAttributeTranslationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FilterAttributeTranslationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributeTranslationPayload>[]
        }
        delete: {
          args: Prisma.FilterAttributeTranslationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributeTranslationPayload>
        }
        update: {
          args: Prisma.FilterAttributeTranslationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributeTranslationPayload>
        }
        deleteMany: {
          args: Prisma.FilterAttributeTranslationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FilterAttributeTranslationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FilterAttributeTranslationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributeTranslationPayload>[]
        }
        upsert: {
          args: Prisma.FilterAttributeTranslationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterAttributeTranslationPayload>
        }
        aggregate: {
          args: Prisma.FilterAttributeTranslationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFilterAttributeTranslation>
        }
        groupBy: {
          args: Prisma.FilterAttributeTranslationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FilterAttributeTranslationGroupByOutputType>[]
        }
        count: {
          args: Prisma.FilterAttributeTranslationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FilterAttributeTranslationCountAggregateOutputType> | number
        }
      }
    }
    ProductFilter: {
      payload: Prisma.$ProductFilterPayload<ExtArgs>
      fields: Prisma.ProductFilterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductFilterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductFilterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductFilterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductFilterPayload>
        }
        findFirst: {
          args: Prisma.ProductFilterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductFilterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductFilterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductFilterPayload>
        }
        findMany: {
          args: Prisma.ProductFilterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductFilterPayload>[]
        }
        create: {
          args: Prisma.ProductFilterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductFilterPayload>
        }
        createMany: {
          args: Prisma.ProductFilterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductFilterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductFilterPayload>[]
        }
        delete: {
          args: Prisma.ProductFilterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductFilterPayload>
        }
        update: {
          args: Prisma.ProductFilterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductFilterPayload>
        }
        deleteMany: {
          args: Prisma.ProductFilterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductFilterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductFilterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductFilterPayload>[]
        }
        upsert: {
          args: Prisma.ProductFilterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductFilterPayload>
        }
        aggregate: {
          args: Prisma.ProductFilterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductFilter>
        }
        groupBy: {
          args: Prisma.ProductFilterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductFilterGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductFilterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductFilterCountAggregateOutputType> | number
        }
      }
    }
    CategoryFilter: {
      payload: Prisma.$CategoryFilterPayload<ExtArgs>
      fields: Prisma.CategoryFilterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CategoryFilterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryFilterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CategoryFilterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryFilterPayload>
        }
        findFirst: {
          args: Prisma.CategoryFilterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryFilterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CategoryFilterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryFilterPayload>
        }
        findMany: {
          args: Prisma.CategoryFilterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryFilterPayload>[]
        }
        create: {
          args: Prisma.CategoryFilterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryFilterPayload>
        }
        createMany: {
          args: Prisma.CategoryFilterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CategoryFilterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryFilterPayload>[]
        }
        delete: {
          args: Prisma.CategoryFilterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryFilterPayload>
        }
        update: {
          args: Prisma.CategoryFilterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryFilterPayload>
        }
        deleteMany: {
          args: Prisma.CategoryFilterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CategoryFilterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CategoryFilterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryFilterPayload>[]
        }
        upsert: {
          args: Prisma.CategoryFilterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryFilterPayload>
        }
        aggregate: {
          args: Prisma.CategoryFilterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategoryFilter>
        }
        groupBy: {
          args: Prisma.CategoryFilterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryFilterGroupByOutputType>[]
        }
        count: {
          args: Prisma.CategoryFilterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryFilterCountAggregateOutputType> | number
        }
      }
    }
    ProductVariant: {
      payload: Prisma.$ProductVariantPayload<ExtArgs>
      fields: Prisma.ProductVariantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductVariantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductVariantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        findFirst: {
          args: Prisma.ProductVariantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductVariantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        findMany: {
          args: Prisma.ProductVariantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
        }
        create: {
          args: Prisma.ProductVariantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        createMany: {
          args: Prisma.ProductVariantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductVariantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
        }
        delete: {
          args: Prisma.ProductVariantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        update: {
          args: Prisma.ProductVariantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        deleteMany: {
          args: Prisma.ProductVariantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductVariantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductVariantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
        }
        upsert: {
          args: Prisma.ProductVariantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductVariantPayload>
        }
        aggregate: {
          args: Prisma.ProductVariantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductVariant>
        }
        groupBy: {
          args: Prisma.ProductVariantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductVariantGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductVariantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductVariantCountAggregateOutputType> | number
        }
      }
    }
    VariantOptionMeta: {
      payload: Prisma.$VariantOptionMetaPayload<ExtArgs>
      fields: Prisma.VariantOptionMetaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VariantOptionMetaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantOptionMetaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VariantOptionMetaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantOptionMetaPayload>
        }
        findFirst: {
          args: Prisma.VariantOptionMetaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantOptionMetaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VariantOptionMetaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantOptionMetaPayload>
        }
        findMany: {
          args: Prisma.VariantOptionMetaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantOptionMetaPayload>[]
        }
        create: {
          args: Prisma.VariantOptionMetaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantOptionMetaPayload>
        }
        createMany: {
          args: Prisma.VariantOptionMetaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VariantOptionMetaCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantOptionMetaPayload>[]
        }
        delete: {
          args: Prisma.VariantOptionMetaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantOptionMetaPayload>
        }
        update: {
          args: Prisma.VariantOptionMetaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantOptionMetaPayload>
        }
        deleteMany: {
          args: Prisma.VariantOptionMetaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VariantOptionMetaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VariantOptionMetaUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantOptionMetaPayload>[]
        }
        upsert: {
          args: Prisma.VariantOptionMetaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VariantOptionMetaPayload>
        }
        aggregate: {
          args: Prisma.VariantOptionMetaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVariantOptionMeta>
        }
        groupBy: {
          args: Prisma.VariantOptionMetaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantOptionMetaGroupByOutputType>[]
        }
        count: {
          args: Prisma.VariantOptionMetaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VariantOptionMetaCountAggregateOutputType> | number
        }
      }
    }
    ProductCustomizationOption: {
      payload: Prisma.$ProductCustomizationOptionPayload<ExtArgs>
      fields: Prisma.ProductCustomizationOptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductCustomizationOptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductCustomizationOptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionPayload>
        }
        findFirst: {
          args: Prisma.ProductCustomizationOptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductCustomizationOptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionPayload>
        }
        findMany: {
          args: Prisma.ProductCustomizationOptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionPayload>[]
        }
        create: {
          args: Prisma.ProductCustomizationOptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionPayload>
        }
        createMany: {
          args: Prisma.ProductCustomizationOptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductCustomizationOptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionPayload>[]
        }
        delete: {
          args: Prisma.ProductCustomizationOptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionPayload>
        }
        update: {
          args: Prisma.ProductCustomizationOptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionPayload>
        }
        deleteMany: {
          args: Prisma.ProductCustomizationOptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductCustomizationOptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductCustomizationOptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionPayload>[]
        }
        upsert: {
          args: Prisma.ProductCustomizationOptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionPayload>
        }
        aggregate: {
          args: Prisma.ProductCustomizationOptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductCustomizationOption>
        }
        groupBy: {
          args: Prisma.ProductCustomizationOptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCustomizationOptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductCustomizationOptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCustomizationOptionCountAggregateOutputType> | number
        }
      }
    }
    ProductCustomizationOptionTranslation: {
      payload: Prisma.$ProductCustomizationOptionTranslationPayload<ExtArgs>
      fields: Prisma.ProductCustomizationOptionTranslationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductCustomizationOptionTranslationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionTranslationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductCustomizationOptionTranslationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionTranslationPayload>
        }
        findFirst: {
          args: Prisma.ProductCustomizationOptionTranslationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionTranslationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductCustomizationOptionTranslationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionTranslationPayload>
        }
        findMany: {
          args: Prisma.ProductCustomizationOptionTranslationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionTranslationPayload>[]
        }
        create: {
          args: Prisma.ProductCustomizationOptionTranslationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionTranslationPayload>
        }
        createMany: {
          args: Prisma.ProductCustomizationOptionTranslationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductCustomizationOptionTranslationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionTranslationPayload>[]
        }
        delete: {
          args: Prisma.ProductCustomizationOptionTranslationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionTranslationPayload>
        }
        update: {
          args: Prisma.ProductCustomizationOptionTranslationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionTranslationPayload>
        }
        deleteMany: {
          args: Prisma.ProductCustomizationOptionTranslationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductCustomizationOptionTranslationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductCustomizationOptionTranslationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionTranslationPayload>[]
        }
        upsert: {
          args: Prisma.ProductCustomizationOptionTranslationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionTranslationPayload>
        }
        aggregate: {
          args: Prisma.ProductCustomizationOptionTranslationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductCustomizationOptionTranslation>
        }
        groupBy: {
          args: Prisma.ProductCustomizationOptionTranslationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCustomizationOptionTranslationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductCustomizationOptionTranslationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCustomizationOptionTranslationCountAggregateOutputType> | number
        }
      }
    }
    ProductCustomizationOptionValue: {
      payload: Prisma.$ProductCustomizationOptionValuePayload<ExtArgs>
      fields: Prisma.ProductCustomizationOptionValueFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductCustomizationOptionValueFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValuePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductCustomizationOptionValueFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValuePayload>
        }
        findFirst: {
          args: Prisma.ProductCustomizationOptionValueFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValuePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductCustomizationOptionValueFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValuePayload>
        }
        findMany: {
          args: Prisma.ProductCustomizationOptionValueFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValuePayload>[]
        }
        create: {
          args: Prisma.ProductCustomizationOptionValueCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValuePayload>
        }
        createMany: {
          args: Prisma.ProductCustomizationOptionValueCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductCustomizationOptionValueCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValuePayload>[]
        }
        delete: {
          args: Prisma.ProductCustomizationOptionValueDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValuePayload>
        }
        update: {
          args: Prisma.ProductCustomizationOptionValueUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValuePayload>
        }
        deleteMany: {
          args: Prisma.ProductCustomizationOptionValueDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductCustomizationOptionValueUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductCustomizationOptionValueUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValuePayload>[]
        }
        upsert: {
          args: Prisma.ProductCustomizationOptionValueUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValuePayload>
        }
        aggregate: {
          args: Prisma.ProductCustomizationOptionValueAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductCustomizationOptionValue>
        }
        groupBy: {
          args: Prisma.ProductCustomizationOptionValueGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCustomizationOptionValueGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductCustomizationOptionValueCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCustomizationOptionValueCountAggregateOutputType> | number
        }
      }
    }
    ProductCustomizationOptionValueTranslation: {
      payload: Prisma.$ProductCustomizationOptionValueTranslationPayload<ExtArgs>
      fields: Prisma.ProductCustomizationOptionValueTranslationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductCustomizationOptionValueTranslationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValueTranslationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductCustomizationOptionValueTranslationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValueTranslationPayload>
        }
        findFirst: {
          args: Prisma.ProductCustomizationOptionValueTranslationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValueTranslationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductCustomizationOptionValueTranslationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValueTranslationPayload>
        }
        findMany: {
          args: Prisma.ProductCustomizationOptionValueTranslationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValueTranslationPayload>[]
        }
        create: {
          args: Prisma.ProductCustomizationOptionValueTranslationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValueTranslationPayload>
        }
        createMany: {
          args: Prisma.ProductCustomizationOptionValueTranslationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductCustomizationOptionValueTranslationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValueTranslationPayload>[]
        }
        delete: {
          args: Prisma.ProductCustomizationOptionValueTranslationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValueTranslationPayload>
        }
        update: {
          args: Prisma.ProductCustomizationOptionValueTranslationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValueTranslationPayload>
        }
        deleteMany: {
          args: Prisma.ProductCustomizationOptionValueTranslationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductCustomizationOptionValueTranslationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductCustomizationOptionValueTranslationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValueTranslationPayload>[]
        }
        upsert: {
          args: Prisma.ProductCustomizationOptionValueTranslationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCustomizationOptionValueTranslationPayload>
        }
        aggregate: {
          args: Prisma.ProductCustomizationOptionValueTranslationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProductCustomizationOptionValueTranslation>
        }
        groupBy: {
          args: Prisma.ProductCustomizationOptionValueTranslationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCustomizationOptionValueTranslationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductCustomizationOptionValueTranslationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductCustomizationOptionValueTranslationCountAggregateOutputType> | number
        }
      }
    }
    Discount: {
      payload: Prisma.$DiscountPayload<ExtArgs>
      fields: Prisma.DiscountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DiscountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DiscountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        findFirst: {
          args: Prisma.DiscountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DiscountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        findMany: {
          args: Prisma.DiscountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>[]
        }
        create: {
          args: Prisma.DiscountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        createMany: {
          args: Prisma.DiscountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DiscountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>[]
        }
        delete: {
          args: Prisma.DiscountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        update: {
          args: Prisma.DiscountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        deleteMany: {
          args: Prisma.DiscountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DiscountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DiscountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>[]
        }
        upsert: {
          args: Prisma.DiscountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        aggregate: {
          args: Prisma.DiscountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDiscount>
        }
        groupBy: {
          args: Prisma.DiscountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountGroupByOutputType>[]
        }
        count: {
          args: Prisma.DiscountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountCountAggregateOutputType> | number
        }
      }
    }
    DiscountProduct: {
      payload: Prisma.$DiscountProductPayload<ExtArgs>
      fields: Prisma.DiscountProductFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DiscountProductFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountProductPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DiscountProductFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountProductPayload>
        }
        findFirst: {
          args: Prisma.DiscountProductFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountProductPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DiscountProductFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountProductPayload>
        }
        findMany: {
          args: Prisma.DiscountProductFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountProductPayload>[]
        }
        create: {
          args: Prisma.DiscountProductCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountProductPayload>
        }
        createMany: {
          args: Prisma.DiscountProductCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DiscountProductCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountProductPayload>[]
        }
        delete: {
          args: Prisma.DiscountProductDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountProductPayload>
        }
        update: {
          args: Prisma.DiscountProductUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountProductPayload>
        }
        deleteMany: {
          args: Prisma.DiscountProductDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DiscountProductUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DiscountProductUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountProductPayload>[]
        }
        upsert: {
          args: Prisma.DiscountProductUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountProductPayload>
        }
        aggregate: {
          args: Prisma.DiscountProductAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDiscountProduct>
        }
        groupBy: {
          args: Prisma.DiscountProductGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountProductGroupByOutputType>[]
        }
        count: {
          args: Prisma.DiscountProductCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountProductCountAggregateOutputType> | number
        }
      }
    }
    DiscountCategory: {
      payload: Prisma.$DiscountCategoryPayload<ExtArgs>
      fields: Prisma.DiscountCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DiscountCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DiscountCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCategoryPayload>
        }
        findFirst: {
          args: Prisma.DiscountCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DiscountCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCategoryPayload>
        }
        findMany: {
          args: Prisma.DiscountCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCategoryPayload>[]
        }
        create: {
          args: Prisma.DiscountCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCategoryPayload>
        }
        createMany: {
          args: Prisma.DiscountCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DiscountCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCategoryPayload>[]
        }
        delete: {
          args: Prisma.DiscountCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCategoryPayload>
        }
        update: {
          args: Prisma.DiscountCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCategoryPayload>
        }
        deleteMany: {
          args: Prisma.DiscountCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DiscountCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DiscountCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCategoryPayload>[]
        }
        upsert: {
          args: Prisma.DiscountCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCategoryPayload>
        }
        aggregate: {
          args: Prisma.DiscountCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDiscountCategory>
        }
        groupBy: {
          args: Prisma.DiscountCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.DiscountCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountCategoryCountAggregateOutputType> | number
        }
      }
    }
    DiscountBrand: {
      payload: Prisma.$DiscountBrandPayload<ExtArgs>
      fields: Prisma.DiscountBrandFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DiscountBrandFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountBrandPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DiscountBrandFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountBrandPayload>
        }
        findFirst: {
          args: Prisma.DiscountBrandFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountBrandPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DiscountBrandFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountBrandPayload>
        }
        findMany: {
          args: Prisma.DiscountBrandFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountBrandPayload>[]
        }
        create: {
          args: Prisma.DiscountBrandCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountBrandPayload>
        }
        createMany: {
          args: Prisma.DiscountBrandCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DiscountBrandCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountBrandPayload>[]
        }
        delete: {
          args: Prisma.DiscountBrandDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountBrandPayload>
        }
        update: {
          args: Prisma.DiscountBrandUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountBrandPayload>
        }
        deleteMany: {
          args: Prisma.DiscountBrandDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DiscountBrandUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DiscountBrandUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountBrandPayload>[]
        }
        upsert: {
          args: Prisma.DiscountBrandUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountBrandPayload>
        }
        aggregate: {
          args: Prisma.DiscountBrandAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDiscountBrand>
        }
        groupBy: {
          args: Prisma.DiscountBrandGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountBrandGroupByOutputType>[]
        }
        count: {
          args: Prisma.DiscountBrandCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountBrandCountAggregateOutputType> | number
        }
      }
    }
    PromoCode: {
      payload: Prisma.$PromoCodePayload<ExtArgs>
      fields: Prisma.PromoCodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodePayload>
        }
        findFirst: {
          args: Prisma.PromoCodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodePayload>
        }
        findMany: {
          args: Prisma.PromoCodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
        }
        create: {
          args: Prisma.PromoCodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodePayload>
        }
        createMany: {
          args: Prisma.PromoCodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PromoCodeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
        }
        delete: {
          args: Prisma.PromoCodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodePayload>
        }
        update: {
          args: Prisma.PromoCodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodePayload>
        }
        deleteMany: {
          args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PromoCodeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
        }
        upsert: {
          args: Prisma.PromoCodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodePayload>
        }
        aggregate: {
          args: Prisma.PromoCodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePromoCode>
        }
        groupBy: {
          args: Prisma.PromoCodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PromoCodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.PromoCodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PromoCodeCountAggregateOutputType> | number
        }
      }
    }
    PromoCodeProduct: {
      payload: Prisma.$PromoCodeProductPayload<ExtArgs>
      fields: Prisma.PromoCodeProductFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PromoCodeProductFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeProductPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PromoCodeProductFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeProductPayload>
        }
        findFirst: {
          args: Prisma.PromoCodeProductFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeProductPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PromoCodeProductFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeProductPayload>
        }
        findMany: {
          args: Prisma.PromoCodeProductFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeProductPayload>[]
        }
        create: {
          args: Prisma.PromoCodeProductCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeProductPayload>
        }
        createMany: {
          args: Prisma.PromoCodeProductCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PromoCodeProductCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeProductPayload>[]
        }
        delete: {
          args: Prisma.PromoCodeProductDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeProductPayload>
        }
        update: {
          args: Prisma.PromoCodeProductUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeProductPayload>
        }
        deleteMany: {
          args: Prisma.PromoCodeProductDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PromoCodeProductUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PromoCodeProductUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeProductPayload>[]
        }
        upsert: {
          args: Prisma.PromoCodeProductUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeProductPayload>
        }
        aggregate: {
          args: Prisma.PromoCodeProductAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePromoCodeProduct>
        }
        groupBy: {
          args: Prisma.PromoCodeProductGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PromoCodeProductGroupByOutputType>[]
        }
        count: {
          args: Prisma.PromoCodeProductCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PromoCodeProductCountAggregateOutputType> | number
        }
      }
    }
    PromoCodeCategory: {
      payload: Prisma.$PromoCodeCategoryPayload<ExtArgs>
      fields: Prisma.PromoCodeCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PromoCodeCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PromoCodeCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeCategoryPayload>
        }
        findFirst: {
          args: Prisma.PromoCodeCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PromoCodeCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeCategoryPayload>
        }
        findMany: {
          args: Prisma.PromoCodeCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeCategoryPayload>[]
        }
        create: {
          args: Prisma.PromoCodeCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeCategoryPayload>
        }
        createMany: {
          args: Prisma.PromoCodeCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PromoCodeCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeCategoryPayload>[]
        }
        delete: {
          args: Prisma.PromoCodeCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeCategoryPayload>
        }
        update: {
          args: Prisma.PromoCodeCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeCategoryPayload>
        }
        deleteMany: {
          args: Prisma.PromoCodeCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PromoCodeCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PromoCodeCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeCategoryPayload>[]
        }
        upsert: {
          args: Prisma.PromoCodeCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeCategoryPayload>
        }
        aggregate: {
          args: Prisma.PromoCodeCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePromoCodeCategory>
        }
        groupBy: {
          args: Prisma.PromoCodeCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PromoCodeCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.PromoCodeCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PromoCodeCategoryCountAggregateOutputType> | number
        }
      }
    }
    PromoCodeBrand: {
      payload: Prisma.$PromoCodeBrandPayload<ExtArgs>
      fields: Prisma.PromoCodeBrandFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PromoCodeBrandFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeBrandPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PromoCodeBrandFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeBrandPayload>
        }
        findFirst: {
          args: Prisma.PromoCodeBrandFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeBrandPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PromoCodeBrandFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeBrandPayload>
        }
        findMany: {
          args: Prisma.PromoCodeBrandFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeBrandPayload>[]
        }
        create: {
          args: Prisma.PromoCodeBrandCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeBrandPayload>
        }
        createMany: {
          args: Prisma.PromoCodeBrandCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PromoCodeBrandCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeBrandPayload>[]
        }
        delete: {
          args: Prisma.PromoCodeBrandDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeBrandPayload>
        }
        update: {
          args: Prisma.PromoCodeBrandUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeBrandPayload>
        }
        deleteMany: {
          args: Prisma.PromoCodeBrandDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PromoCodeBrandUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PromoCodeBrandUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeBrandPayload>[]
        }
        upsert: {
          args: Prisma.PromoCodeBrandUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PromoCodeBrandPayload>
        }
        aggregate: {
          args: Prisma.PromoCodeBrandAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePromoCodeBrand>
        }
        groupBy: {
          args: Prisma.PromoCodeBrandGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PromoCodeBrandGroupByOutputType>[]
        }
        count: {
          args: Prisma.PromoCodeBrandCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PromoCodeBrandCountAggregateOutputType> | number
        }
      }
    }
    GiftCard: {
      payload: Prisma.$GiftCardPayload<ExtArgs>
      fields: Prisma.GiftCardFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GiftCardFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GiftCardPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GiftCardFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GiftCardPayload>
        }
        findFirst: {
          args: Prisma.GiftCardFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GiftCardPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GiftCardFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GiftCardPayload>
        }
        findMany: {
          args: Prisma.GiftCardFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GiftCardPayload>[]
        }
        create: {
          args: Prisma.GiftCardCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GiftCardPayload>
        }
        createMany: {
          args: Prisma.GiftCardCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GiftCardCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GiftCardPayload>[]
        }
        delete: {
          args: Prisma.GiftCardDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GiftCardPayload>
        }
        update: {
          args: Prisma.GiftCardUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GiftCardPayload>
        }
        deleteMany: {
          args: Prisma.GiftCardDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GiftCardUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GiftCardUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GiftCardPayload>[]
        }
        upsert: {
          args: Prisma.GiftCardUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GiftCardPayload>
        }
        aggregate: {
          args: Prisma.GiftCardAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGiftCard>
        }
        groupBy: {
          args: Prisma.GiftCardGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GiftCardGroupByOutputType>[]
        }
        count: {
          args: Prisma.GiftCardCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GiftCardCountAggregateOutputType> | number
        }
      }
    }
    Cart: {
      payload: Prisma.$CartPayload<ExtArgs>
      fields: Prisma.CartFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CartFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        findFirst: {
          args: Prisma.CartFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        findMany: {
          args: Prisma.CartFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>[]
        }
        create: {
          args: Prisma.CartCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        createMany: {
          args: Prisma.CartCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>[]
        }
        delete: {
          args: Prisma.CartDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        update: {
          args: Prisma.CartUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        deleteMany: {
          args: Prisma.CartDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CartUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>[]
        }
        upsert: {
          args: Prisma.CartUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartPayload>
        }
        aggregate: {
          args: Prisma.CartAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCart>
        }
        groupBy: {
          args: Prisma.CartGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CartGroupByOutputType>[]
        }
        count: {
          args: Prisma.CartCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CartCountAggregateOutputType> | number
        }
      }
    }
    CartItem: {
      payload: Prisma.$CartItemPayload<ExtArgs>
      fields: Prisma.CartItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CartItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        findFirst: {
          args: Prisma.CartItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        findMany: {
          args: Prisma.CartItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>[]
        }
        create: {
          args: Prisma.CartItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        createMany: {
          args: Prisma.CartItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>[]
        }
        delete: {
          args: Prisma.CartItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        update: {
          args: Prisma.CartItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        deleteMany: {
          args: Prisma.CartItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CartItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CartItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>[]
        }
        upsert: {
          args: Prisma.CartItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CartItemPayload>
        }
        aggregate: {
          args: Prisma.CartItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCartItem>
        }
        groupBy: {
          args: Prisma.CartItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CartItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.CartItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CartItemCountAggregateOutputType> | number
        }
      }
    }
    Order: {
      payload: Prisma.$OrderPayload<ExtArgs>
      fields: Prisma.OrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        findFirst: {
          args: Prisma.OrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        findMany: {
          args: Prisma.OrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        create: {
          args: Prisma.OrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        createMany: {
          args: Prisma.OrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        delete: {
          args: Prisma.OrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        update: {
          args: Prisma.OrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        deleteMany: {
          args: Prisma.OrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        upsert: {
          args: Prisma.OrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        aggregate: {
          args: Prisma.OrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrder>
        }
        groupBy: {
          args: Prisma.OrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderCountAggregateOutputType> | number
        }
      }
    }
    OrderItem: {
      payload: Prisma.$OrderItemPayload<ExtArgs>
      fields: Prisma.OrderItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        findFirst: {
          args: Prisma.OrderItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        findMany: {
          args: Prisma.OrderItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
        }
        create: {
          args: Prisma.OrderItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        createMany: {
          args: Prisma.OrderItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
        }
        delete: {
          args: Prisma.OrderItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        update: {
          args: Prisma.OrderItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        deleteMany: {
          args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
        }
        upsert: {
          args: Prisma.OrderItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderItemPayload>
        }
        aggregate: {
          args: Prisma.OrderItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrderItem>
        }
        groupBy: {
          args: Prisma.OrderItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrderItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderItemCountAggregateOutputType> | number
        }
      }
    }
    OrderHistory: {
      payload: Prisma.$OrderHistoryPayload<ExtArgs>
      fields: Prisma.OrderHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrderHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrderHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
        }
        findFirst: {
          args: Prisma.OrderHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrderHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
        }
        findMany: {
          args: Prisma.OrderHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderHistoryPayload>[]
        }
        create: {
          args: Prisma.OrderHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
        }
        createMany: {
          args: Prisma.OrderHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrderHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderHistoryPayload>[]
        }
        delete: {
          args: Prisma.OrderHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
        }
        update: {
          args: Prisma.OrderHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
        }
        deleteMany: {
          args: Prisma.OrderHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrderHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrderHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderHistoryPayload>[]
        }
        upsert: {
          args: Prisma.OrderHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderHistoryPayload>
        }
        aggregate: {
          args: Prisma.OrderHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrderHistory>
        }
        groupBy: {
          args: Prisma.OrderHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrderHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderHistoryCountAggregateOutputType> | number
        }
      }
    }
    ShippingMethod: {
      payload: Prisma.$ShippingMethodPayload<ExtArgs>
      fields: Prisma.ShippingMethodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ShippingMethodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShippingMethodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ShippingMethodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
        }
        findFirst: {
          args: Prisma.ShippingMethodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShippingMethodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ShippingMethodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
        }
        findMany: {
          args: Prisma.ShippingMethodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShippingMethodPayload>[]
        }
        create: {
          args: Prisma.ShippingMethodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
        }
        createMany: {
          args: Prisma.ShippingMethodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ShippingMethodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShippingMethodPayload>[]
        }
        delete: {
          args: Prisma.ShippingMethodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
        }
        update: {
          args: Prisma.ShippingMethodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
        }
        deleteMany: {
          args: Prisma.ShippingMethodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ShippingMethodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ShippingMethodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShippingMethodPayload>[]
        }
        upsert: {
          args: Prisma.ShippingMethodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
        }
        aggregate: {
          args: Prisma.ShippingMethodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateShippingMethod>
        }
        groupBy: {
          args: Prisma.ShippingMethodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ShippingMethodGroupByOutputType>[]
        }
        count: {
          args: Prisma.ShippingMethodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ShippingMethodCountAggregateOutputType> | number
        }
      }
    }
    PaymentMethod: {
      payload: Prisma.$PaymentMethodPayload<ExtArgs>
      fields: Prisma.PaymentMethodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        findFirst: {
          args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        findMany: {
          args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
        }
        create: {
          args: Prisma.PaymentMethodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        createMany: {
          args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
        }
        delete: {
          args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        update: {
          args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        deleteMany: {
          args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
        }
        upsert: {
          args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        aggregate: {
          args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentMethod>
        }
        groupBy: {
          args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentMethodGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentMethodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentMethodCountAggregateOutputType> | number
        }
      }
    }
    UserAddress: {
      payload: Prisma.$UserAddressPayload<ExtArgs>
      fields: Prisma.UserAddressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserAddressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserAddressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAddressPayload>
        }
        findFirst: {
          args: Prisma.UserAddressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserAddressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAddressPayload>
        }
        findMany: {
          args: Prisma.UserAddressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
        }
        create: {
          args: Prisma.UserAddressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAddressPayload>
        }
        createMany: {
          args: Prisma.UserAddressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserAddressCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
        }
        delete: {
          args: Prisma.UserAddressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAddressPayload>
        }
        update: {
          args: Prisma.UserAddressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAddressPayload>
        }
        deleteMany: {
          args: Prisma.UserAddressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserAddressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserAddressUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
        }
        upsert: {
          args: Prisma.UserAddressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAddressPayload>
        }
        aggregate: {
          args: Prisma.UserAddressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserAddress>
        }
        groupBy: {
          args: Prisma.UserAddressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserAddressGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserAddressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserAddressCountAggregateOutputType> | number
        }
      }
    }
    WishlistItem: {
      payload: Prisma.$WishlistItemPayload<ExtArgs>
      fields: Prisma.WishlistItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WishlistItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WishlistItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WishlistItemPayload>
        }
        findFirst: {
          args: Prisma.WishlistItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WishlistItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WishlistItemPayload>
        }
        findMany: {
          args: Prisma.WishlistItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
        }
        create: {
          args: Prisma.WishlistItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WishlistItemPayload>
        }
        createMany: {
          args: Prisma.WishlistItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WishlistItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
        }
        delete: {
          args: Prisma.WishlistItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WishlistItemPayload>
        }
        update: {
          args: Prisma.WishlistItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WishlistItemPayload>
        }
        deleteMany: {
          args: Prisma.WishlistItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WishlistItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WishlistItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
        }
        upsert: {
          args: Prisma.WishlistItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WishlistItemPayload>
        }
        aggregate: {
          args: Prisma.WishlistItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWishlistItem>
        }
        groupBy: {
          args: Prisma.WishlistItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WishlistItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.WishlistItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WishlistItemCountAggregateOutputType> | number
        }
      }
    }
    Review: {
      payload: Prisma.$ReviewPayload<ExtArgs>
      fields: Prisma.ReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        findFirst: {
          args: Prisma.ReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        findMany: {
          args: Prisma.ReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>[]
        }
        create: {
          args: Prisma.ReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        createMany: {
          args: Prisma.ReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>[]
        }
        delete: {
          args: Prisma.ReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        update: {
          args: Prisma.ReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        deleteMany: {
          args: Prisma.ReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>[]
        }
        upsert: {
          args: Prisma.ReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        aggregate: {
          args: Prisma.ReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReview>
        }
        groupBy: {
          args: Prisma.ReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReviewCountAggregateOutputType> | number
        }
      }
    }
    Media: {
      payload: Prisma.$MediaPayload<ExtArgs>
      fields: Prisma.MediaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MediaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        findFirst: {
          args: Prisma.MediaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        findMany: {
          args: Prisma.MediaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>[]
        }
        create: {
          args: Prisma.MediaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        createMany: {
          args: Prisma.MediaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>[]
        }
        delete: {
          args: Prisma.MediaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        update: {
          args: Prisma.MediaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        deleteMany: {
          args: Prisma.MediaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MediaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>[]
        }
        upsert: {
          args: Prisma.MediaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        aggregate: {
          args: Prisma.MediaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMedia>
        }
        groupBy: {
          args: Prisma.MediaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MediaGroupByOutputType>[]
        }
        count: {
          args: Prisma.MediaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MediaCountAggregateOutputType> | number
        }
      }
    }
    BlogPost: {
      payload: Prisma.$BlogPostPayload<ExtArgs>
      fields: Prisma.BlogPostFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostPayload>
        }
        findFirst: {
          args: Prisma.BlogPostFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostPayload>
        }
        findMany: {
          args: Prisma.BlogPostFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
        }
        create: {
          args: Prisma.BlogPostCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostPayload>
        }
        createMany: {
          args: Prisma.BlogPostCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
        }
        delete: {
          args: Prisma.BlogPostDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostPayload>
        }
        update: {
          args: Prisma.BlogPostUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostPayload>
        }
        deleteMany: {
          args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BlogPostUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
        }
        upsert: {
          args: Prisma.BlogPostUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostPayload>
        }
        aggregate: {
          args: Prisma.BlogPostAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBlogPost>
        }
        groupBy: {
          args: Prisma.BlogPostGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BlogPostGroupByOutputType>[]
        }
        count: {
          args: Prisma.BlogPostCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BlogPostCountAggregateOutputType> | number
        }
      }
    }
    BlogPostTranslation: {
      payload: Prisma.$BlogPostTranslationPayload<ExtArgs>
      fields: Prisma.BlogPostTranslationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BlogPostTranslationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostTranslationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BlogPostTranslationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostTranslationPayload>
        }
        findFirst: {
          args: Prisma.BlogPostTranslationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostTranslationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BlogPostTranslationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostTranslationPayload>
        }
        findMany: {
          args: Prisma.BlogPostTranslationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostTranslationPayload>[]
        }
        create: {
          args: Prisma.BlogPostTranslationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostTranslationPayload>
        }
        createMany: {
          args: Prisma.BlogPostTranslationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BlogPostTranslationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostTranslationPayload>[]
        }
        delete: {
          args: Prisma.BlogPostTranslationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostTranslationPayload>
        }
        update: {
          args: Prisma.BlogPostTranslationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostTranslationPayload>
        }
        deleteMany: {
          args: Prisma.BlogPostTranslationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BlogPostTranslationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BlogPostTranslationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostTranslationPayload>[]
        }
        upsert: {
          args: Prisma.BlogPostTranslationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlogPostTranslationPayload>
        }
        aggregate: {
          args: Prisma.BlogPostTranslationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBlogPostTranslation>
        }
        groupBy: {
          args: Prisma.BlogPostTranslationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BlogPostTranslationGroupByOutputType>[]
        }
        count: {
          args: Prisma.BlogPostTranslationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BlogPostTranslationCountAggregateOutputType> | number
        }
      }
    }
    Page: {
      payload: Prisma.$PagePayload<ExtArgs>
      fields: Prisma.PageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        findFirst: {
          args: Prisma.PageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        findMany: {
          args: Prisma.PageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>[]
        }
        create: {
          args: Prisma.PageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        createMany: {
          args: Prisma.PageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>[]
        }
        delete: {
          args: Prisma.PageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        update: {
          args: Prisma.PageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        deleteMany: {
          args: Prisma.PageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>[]
        }
        upsert: {
          args: Prisma.PageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        aggregate: {
          args: Prisma.PageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePage>
        }
        groupBy: {
          args: Prisma.PageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PageGroupByOutputType>[]
        }
        count: {
          args: Prisma.PageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PageCountAggregateOutputType> | number
        }
      }
    }
    PageTranslation: {
      payload: Prisma.$PageTranslationPayload<ExtArgs>
      fields: Prisma.PageTranslationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PageTranslationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageTranslationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PageTranslationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageTranslationPayload>
        }
        findFirst: {
          args: Prisma.PageTranslationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageTranslationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PageTranslationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageTranslationPayload>
        }
        findMany: {
          args: Prisma.PageTranslationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageTranslationPayload>[]
        }
        create: {
          args: Prisma.PageTranslationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageTranslationPayload>
        }
        createMany: {
          args: Prisma.PageTranslationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PageTranslationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageTranslationPayload>[]
        }
        delete: {
          args: Prisma.PageTranslationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageTranslationPayload>
        }
        update: {
          args: Prisma.PageTranslationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageTranslationPayload>
        }
        deleteMany: {
          args: Prisma.PageTranslationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PageTranslationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PageTranslationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageTranslationPayload>[]
        }
        upsert: {
          args: Prisma.PageTranslationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PageTranslationPayload>
        }
        aggregate: {
          args: Prisma.PageTranslationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePageTranslation>
        }
        groupBy: {
          args: Prisma.PageTranslationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PageTranslationGroupByOutputType>[]
        }
        count: {
          args: Prisma.PageTranslationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PageTranslationCountAggregateOutputType> | number
        }
      }
    }
    Collection: {
      payload: Prisma.$CollectionPayload<ExtArgs>
      fields: Prisma.CollectionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CollectionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CollectionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionPayload>
        }
        findFirst: {
          args: Prisma.CollectionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CollectionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionPayload>
        }
        findMany: {
          args: Prisma.CollectionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionPayload>[]
        }
        create: {
          args: Prisma.CollectionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionPayload>
        }
        createMany: {
          args: Prisma.CollectionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CollectionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionPayload>[]
        }
        delete: {
          args: Prisma.CollectionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionPayload>
        }
        update: {
          args: Prisma.CollectionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionPayload>
        }
        deleteMany: {
          args: Prisma.CollectionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CollectionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CollectionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionPayload>[]
        }
        upsert: {
          args: Prisma.CollectionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionPayload>
        }
        aggregate: {
          args: Prisma.CollectionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCollection>
        }
        groupBy: {
          args: Prisma.CollectionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CollectionGroupByOutputType>[]
        }
        count: {
          args: Prisma.CollectionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CollectionCountAggregateOutputType> | number
        }
      }
    }
    CollectionTranslation: {
      payload: Prisma.$CollectionTranslationPayload<ExtArgs>
      fields: Prisma.CollectionTranslationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CollectionTranslationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionTranslationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CollectionTranslationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionTranslationPayload>
        }
        findFirst: {
          args: Prisma.CollectionTranslationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionTranslationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CollectionTranslationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionTranslationPayload>
        }
        findMany: {
          args: Prisma.CollectionTranslationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionTranslationPayload>[]
        }
        create: {
          args: Prisma.CollectionTranslationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionTranslationPayload>
        }
        createMany: {
          args: Prisma.CollectionTranslationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CollectionTranslationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionTranslationPayload>[]
        }
        delete: {
          args: Prisma.CollectionTranslationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionTranslationPayload>
        }
        update: {
          args: Prisma.CollectionTranslationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionTranslationPayload>
        }
        deleteMany: {
          args: Prisma.CollectionTranslationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CollectionTranslationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CollectionTranslationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionTranslationPayload>[]
        }
        upsert: {
          args: Prisma.CollectionTranslationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionTranslationPayload>
        }
        aggregate: {
          args: Prisma.CollectionTranslationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCollectionTranslation>
        }
        groupBy: {
          args: Prisma.CollectionTranslationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CollectionTranslationGroupByOutputType>[]
        }
        count: {
          args: Prisma.CollectionTranslationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CollectionTranslationCountAggregateOutputType> | number
        }
      }
    }
    CollectionProduct: {
      payload: Prisma.$CollectionProductPayload<ExtArgs>
      fields: Prisma.CollectionProductFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CollectionProductFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionProductPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CollectionProductFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionProductPayload>
        }
        findFirst: {
          args: Prisma.CollectionProductFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionProductPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CollectionProductFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionProductPayload>
        }
        findMany: {
          args: Prisma.CollectionProductFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionProductPayload>[]
        }
        create: {
          args: Prisma.CollectionProductCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionProductPayload>
        }
        createMany: {
          args: Prisma.CollectionProductCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CollectionProductCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionProductPayload>[]
        }
        delete: {
          args: Prisma.CollectionProductDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionProductPayload>
        }
        update: {
          args: Prisma.CollectionProductUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionProductPayload>
        }
        deleteMany: {
          args: Prisma.CollectionProductDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CollectionProductUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CollectionProductUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionProductPayload>[]
        }
        upsert: {
          args: Prisma.CollectionProductUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CollectionProductPayload>
        }
        aggregate: {
          args: Prisma.CollectionProductAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCollectionProduct>
        }
        groupBy: {
          args: Prisma.CollectionProductGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CollectionProductGroupByOutputType>[]
        }
        count: {
          args: Prisma.CollectionProductCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CollectionProductCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const TenantScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  name: 'name',
  description: 'description',
  email: 'email',
  phone: 'phone',
  logoUrl: 'logoUrl',
  faviconUrl: 'faviconUrl',
  themeId: 'themeId',
  themeConfig: 'themeConfig',
  isActive: 'isActive',
  billingStatus: 'billingStatus',
  billingCycle: 'billingCycle',
  planId: 'planId',
  trialEndsAt: 'trialEndsAt',
  currentPeriodStart: 'currentPeriodStart',
  currentPeriodEnd: 'currentPeriodEnd',
  stripeCustomerId: 'stripeCustomerId',
  stripeSubscriptionId: 'stripeSubscriptionId',
  currency: 'currency',
  locale: 'locale',
  timezone: 'timezone',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


export const TenantStaffScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  userId: 'userId',
  role: 'role',
  permissions: 'permissions',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantStaffScalarFieldEnum = (typeof TenantStaffScalarFieldEnum)[keyof typeof TenantStaffScalarFieldEnum]


export const TenantDomainScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  domain: 'domain',
  isPrimary: 'isPrimary',
  sslStatus: 'sslStatus',
  sslExpiry: 'sslExpiry',
  dnsVerified: 'dnsVerified',
  dnsToken: 'dnsToken',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantDomainScalarFieldEnum = (typeof TenantDomainScalarFieldEnum)[keyof typeof TenantDomainScalarFieldEnum]


export const CustomerScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  email: 'email',
  password: 'password',
  emailVerified: 'emailVerified',
  firstName: 'firstName',
  lastName: 'lastName',
  phone: 'phone',
  isActive: 'isActive',
  acceptsMarketing: 'acceptsMarketing',
  locale: 'locale',
  totalSpent: 'totalSpent',
  ordersCount: 'ordersCount',
  lastOrderAt: 'lastOrderAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


export const CustomerAddressScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  firstName: 'firstName',
  lastName: 'lastName',
  company: 'company',
  address1: 'address1',
  address2: 'address2',
  city: 'city',
  province: 'province',
  country: 'country',
  postalCode: 'postalCode',
  phone: 'phone',
  isDefault: 'isDefault',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CustomerAddressScalarFieldEnum = (typeof CustomerAddressScalarFieldEnum)[keyof typeof CustomerAddressScalarFieldEnum]


export const CustomerSessionScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  token: 'token',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  createdAt: 'createdAt',
  expiresAt: 'expiresAt'
} as const

export type CustomerSessionScalarFieldEnum = (typeof CustomerSessionScalarFieldEnum)[keyof typeof CustomerSessionScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  name: 'name',
  firstName: 'firstName',
  lastName: 'lastName',
  email: 'email',
  emailVerified: 'emailVerified',
  emailVerifiedAt: 'emailVerifiedAt',
  image: 'image',
  password: 'password',
  role: 'role',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const AccountScalarFieldEnum = {
  id: 'id',
  accountId: 'accountId',
  providerId: 'providerId',
  userId: 'userId',
  accessToken: 'accessToken',
  refreshToken: 'refreshToken',
  idToken: 'idToken',
  accessTokenExpiresAt: 'accessTokenExpiresAt',
  refreshTokenExpiresAt: 'refreshTokenExpiresAt',
  scope: 'scope',
  password: 'password',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


export const SessionScalarFieldEnum = {
  id: 'id',
  expiresAt: 'expiresAt',
  token: 'token',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const VerificationScalarFieldEnum = {
  id: 'id',
  identifier: 'identifier',
  value: 'value',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


export const EmailVerificationTokenScalarFieldEnum = {
  id: 'id',
  email: 'email',
  token: 'token',
  expires: 'expires'
} as const

export type EmailVerificationTokenScalarFieldEnum = (typeof EmailVerificationTokenScalarFieldEnum)[keyof typeof EmailVerificationTokenScalarFieldEnum]


export const PasswordResetTokenScalarFieldEnum = {
  id: 'id',
  email: 'email',
  token: 'token',
  expires: 'expires'
} as const

export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


export const LocaleScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  isDefault: 'isDefault'
} as const

export type LocaleScalarFieldEnum = (typeof LocaleScalarFieldEnum)[keyof typeof LocaleScalarFieldEnum]


export const CurrencyScalarFieldEnum = {
  id: 'id',
  code: 'code',
  symbol: 'symbol',
  name: 'name',
  rate: 'rate',
  isDefault: 'isDefault',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


export const BrandScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  name: 'name',
  logoUrl: 'logoUrl',
  description: 'description',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


export const BrandTranslationScalarFieldEnum = {
  id: 'id',
  brandId: 'brandId',
  localeId: 'localeId',
  name: 'name',
  description: 'description'
} as const

export type BrandTranslationScalarFieldEnum = (typeof BrandTranslationScalarFieldEnum)[keyof typeof BrandTranslationScalarFieldEnum]


export const CategoryScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  iconUrl: 'iconUrl',
  coverImageUrl: 'coverImageUrl',
  parentId: 'parentId',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


export const CategoryTranslationScalarFieldEnum = {
  id: 'id',
  categoryId: 'categoryId',
  localeId: 'localeId',
  name: 'name',
  description: 'description'
} as const

export type CategoryTranslationScalarFieldEnum = (typeof CategoryTranslationScalarFieldEnum)[keyof typeof CategoryTranslationScalarFieldEnum]


export const ProductScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  price: 'price',
  sku: 'sku',
  trackStock: 'trackStock',
  stock: 'stock',
  status: 'status',
  tenantId: 'tenantId',
  compareAtPrice: 'compareAtPrice',
  costPerItem: 'costPerItem',
  unitPriceAmount: 'unitPriceAmount',
  unitPriceMeasurement: 'unitPriceMeasurement',
  unitPriceBaseAmount: 'unitPriceBaseAmount',
  unitPriceBaseMeasurement: 'unitPriceBaseMeasurement',
  purchaseType: 'purchaseType',
  subscriptionDiscountPercent: 'subscriptionDiscountPercent',
  subscriptionIntervals: 'subscriptionIntervals',
  preOrderReleaseDate: 'preOrderReleaseDate',
  preOrderDepositPercent: 'preOrderDepositPercent',
  lowStockThreshold: 'lowStockThreshold',
  categoryId: 'categoryId',
  brandId: 'brandId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


export const ProductTranslationScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  localeId: 'localeId',
  name: 'name',
  description: 'description',
  metaTitle: 'metaTitle',
  metaDescription: 'metaDescription',
  customSlug: 'customSlug'
} as const

export type ProductTranslationScalarFieldEnum = (typeof ProductTranslationScalarFieldEnum)[keyof typeof ProductTranslationScalarFieldEnum]


export const ProductMediaScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  url: 'url',
  mediaType: 'mediaType',
  altText: 'altText',
  order: 'order',
  createdAt: 'createdAt'
} as const

export type ProductMediaScalarFieldEnum = (typeof ProductMediaScalarFieldEnum)[keyof typeof ProductMediaScalarFieldEnum]


export const ProductSpecificationScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  order: 'order'
} as const

export type ProductSpecificationScalarFieldEnum = (typeof ProductSpecificationScalarFieldEnum)[keyof typeof ProductSpecificationScalarFieldEnum]


export const ProductSpecificationTranslationScalarFieldEnum = {
  id: 'id',
  specId: 'specId',
  localeId: 'localeId',
  name: 'name',
  value: 'value'
} as const

export type ProductSpecificationTranslationScalarFieldEnum = (typeof ProductSpecificationTranslationScalarFieldEnum)[keyof typeof ProductSpecificationTranslationScalarFieldEnum]


export const ProductShippingInfoScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  packageType: 'packageType',
  packagingWeightKg: 'packagingWeightKg',
  packagingLengthCm: 'packagingLengthCm',
  packagingWidthCm: 'packagingWidthCm',
  packagingHeightCm: 'packagingHeightCm',
  productWeightKg: 'productWeightKg',
  productLengthCm: 'productLengthCm',
  productWidthCm: 'productWidthCm',
  productHeightCm: 'productHeightCm',
  isFragile: 'isFragile',
  isFreeShipping: 'isFreeShipping',
  tags: 'tags'
} as const

export type ProductShippingInfoScalarFieldEnum = (typeof ProductShippingInfoScalarFieldEnum)[keyof typeof ProductShippingInfoScalarFieldEnum]


export const ProductDownloadScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  name: 'name',
  fileUrl: 'fileUrl',
  fileSizeKb: 'fileSizeKb',
  createdAt: 'createdAt'
} as const

export type ProductDownloadScalarFieldEnum = (typeof ProductDownloadScalarFieldEnum)[keyof typeof ProductDownloadScalarFieldEnum]


export const FilterScalarFieldEnum = {
  id: 'id',
  name: 'name',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FilterScalarFieldEnum = (typeof FilterScalarFieldEnum)[keyof typeof FilterScalarFieldEnum]


export const FilterAttributeScalarFieldEnum = {
  id: 'id',
  filterId: 'filterId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FilterAttributeScalarFieldEnum = (typeof FilterAttributeScalarFieldEnum)[keyof typeof FilterAttributeScalarFieldEnum]


export const FilterAttributeTranslationScalarFieldEnum = {
  id: 'id',
  attributeId: 'attributeId',
  localeId: 'localeId',
  name: 'name'
} as const

export type FilterAttributeTranslationScalarFieldEnum = (typeof FilterAttributeTranslationScalarFieldEnum)[keyof typeof FilterAttributeTranslationScalarFieldEnum]


export const ProductFilterScalarFieldEnum = {
  productId: 'productId',
  filterAttributeId: 'filterAttributeId'
} as const

export type ProductFilterScalarFieldEnum = (typeof ProductFilterScalarFieldEnum)[keyof typeof ProductFilterScalarFieldEnum]


export const CategoryFilterScalarFieldEnum = {
  categoryId: 'categoryId',
  filterId: 'filterId'
} as const

export type CategoryFilterScalarFieldEnum = (typeof CategoryFilterScalarFieldEnum)[keyof typeof CategoryFilterScalarFieldEnum]


export const ProductVariantScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  sku: 'sku',
  price: 'price',
  priceAdjustment: 'priceAdjustment',
  stock: 'stock',
  imageUrl: 'imageUrl',
  options: 'options',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProductVariantScalarFieldEnum = (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum]


export const VariantOptionMetaScalarFieldEnum = {
  id: 'id',
  variantId: 'variantId',
  optionName: 'optionName',
  hexColor: 'hexColor'
} as const

export type VariantOptionMetaScalarFieldEnum = (typeof VariantOptionMetaScalarFieldEnum)[keyof typeof VariantOptionMetaScalarFieldEnum]


export const ProductCustomizationOptionScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  type: 'type',
  name: 'name',
  description: 'description',
  isRequired: 'isRequired',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProductCustomizationOptionScalarFieldEnum = (typeof ProductCustomizationOptionScalarFieldEnum)[keyof typeof ProductCustomizationOptionScalarFieldEnum]


export const ProductCustomizationOptionTranslationScalarFieldEnum = {
  id: 'id',
  optionId: 'optionId',
  localeId: 'localeId',
  name: 'name',
  description: 'description'
} as const

export type ProductCustomizationOptionTranslationScalarFieldEnum = (typeof ProductCustomizationOptionTranslationScalarFieldEnum)[keyof typeof ProductCustomizationOptionTranslationScalarFieldEnum]


export const ProductCustomizationOptionValueScalarFieldEnum = {
  id: 'id',
  optionId: 'optionId',
  value: 'value',
  priceAdjustment: 'priceAdjustment',
  stockAdjustment: 'stockAdjustment',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProductCustomizationOptionValueScalarFieldEnum = (typeof ProductCustomizationOptionValueScalarFieldEnum)[keyof typeof ProductCustomizationOptionValueScalarFieldEnum]


export const ProductCustomizationOptionValueTranslationScalarFieldEnum = {
  id: 'id',
  valueId: 'valueId',
  localeId: 'localeId',
  name: 'name'
} as const

export type ProductCustomizationOptionValueTranslationScalarFieldEnum = (typeof ProductCustomizationOptionValueTranslationScalarFieldEnum)[keyof typeof ProductCustomizationOptionValueTranslationScalarFieldEnum]


export const DiscountScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  type: 'type',
  value: 'value',
  scope: 'scope',
  startDate: 'startDate',
  endDate: 'endDate',
  isActive: 'isActive',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


export const DiscountProductScalarFieldEnum = {
  discountId: 'discountId',
  productId: 'productId'
} as const

export type DiscountProductScalarFieldEnum = (typeof DiscountProductScalarFieldEnum)[keyof typeof DiscountProductScalarFieldEnum]


export const DiscountCategoryScalarFieldEnum = {
  discountId: 'discountId',
  categoryId: 'categoryId'
} as const

export type DiscountCategoryScalarFieldEnum = (typeof DiscountCategoryScalarFieldEnum)[keyof typeof DiscountCategoryScalarFieldEnum]


export const DiscountBrandScalarFieldEnum = {
  discountId: 'discountId',
  brandId: 'brandId'
} as const

export type DiscountBrandScalarFieldEnum = (typeof DiscountBrandScalarFieldEnum)[keyof typeof DiscountBrandScalarFieldEnum]


export const PromoCodeScalarFieldEnum = {
  id: 'id',
  code: 'code',
  description: 'description',
  type: 'type',
  value: 'value',
  scope: 'scope',
  startDate: 'startDate',
  endDate: 'endDate',
  maxUses: 'maxUses',
  usesCount: 'usesCount',
  isActive: 'isActive',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


export const PromoCodeProductScalarFieldEnum = {
  promoCodeId: 'promoCodeId',
  productId: 'productId'
} as const

export type PromoCodeProductScalarFieldEnum = (typeof PromoCodeProductScalarFieldEnum)[keyof typeof PromoCodeProductScalarFieldEnum]


export const PromoCodeCategoryScalarFieldEnum = {
  promoCodeId: 'promoCodeId',
  categoryId: 'categoryId'
} as const

export type PromoCodeCategoryScalarFieldEnum = (typeof PromoCodeCategoryScalarFieldEnum)[keyof typeof PromoCodeCategoryScalarFieldEnum]


export const PromoCodeBrandScalarFieldEnum = {
  promoCodeId: 'promoCodeId',
  brandId: 'brandId'
} as const

export type PromoCodeBrandScalarFieldEnum = (typeof PromoCodeBrandScalarFieldEnum)[keyof typeof PromoCodeBrandScalarFieldEnum]


export const GiftCardScalarFieldEnum = {
  id: 'id',
  code: 'code',
  initialValue: 'initialValue',
  currentValue: 'currentValue',
  currencyId: 'currencyId',
  expirationDate: 'expirationDate',
  isActive: 'isActive',
  purchaserId: 'purchaserId',
  recipientId: 'recipientId',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GiftCardScalarFieldEnum = (typeof GiftCardScalarFieldEnum)[keyof typeof GiftCardScalarFieldEnum]


export const CartScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  expiresAt: 'expiresAt',
  tenantId: 'tenantId',
  customerId: 'customerId',
  sessionId: 'sessionId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


export const CartItemScalarFieldEnum = {
  id: 'id',
  cartId: 'cartId',
  productId: 'productId',
  quantity: 'quantity',
  selectedVariantId: 'selectedVariantId',
  selectedCustomizationOptions: 'selectedCustomizationOptions',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


export const OrderScalarFieldEnum = {
  id: 'id',
  orderNumber: 'orderNumber',
  userId: 'userId',
  guestEmail: 'guestEmail',
  status: 'status',
  paymentStatus: 'paymentStatus',
  totalAmount: 'totalAmount',
  shippingCost: 'shippingCost',
  tenantId: 'tenantId',
  customerId: 'customerId',
  discountAmount: 'discountAmount',
  currencyId: 'currencyId',
  promoCodeId: 'promoCodeId',
  giftCardId: 'giftCardId',
  shippingMethodId: 'shippingMethodId',
  shippingFirstName: 'shippingFirstName',
  shippingLastName: 'shippingLastName',
  shippingPhone: 'shippingPhone',
  shippingEmail: 'shippingEmail',
  shippingCompany: 'shippingCompany',
  shippingVatNumber: 'shippingVatNumber',
  shippingCountry: 'shippingCountry',
  shippingCity: 'shippingCity',
  shippingPostcode: 'shippingPostcode',
  shippingAddressLine1: 'shippingAddressLine1',
  shippingAddressLine2: 'shippingAddressLine2',
  shippingNotes: 'shippingNotes',
  deliveryBoxName: 'deliveryBoxName',
  deliveryBoxId: 'deliveryBoxId',
  deliveryOfficeName: 'deliveryOfficeName',
  deliveryOfficeId: 'deliveryOfficeId',
  paymentMethodId: 'paymentMethodId',
  paymentTransactionId: 'paymentTransactionId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  cancelledAt: 'cancelledAt'
} as const

export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


export const OrderItemScalarFieldEnum = {
  id: 'id',
  orderId: 'orderId',
  productId: 'productId',
  selectedVariantId: 'selectedVariantId',
  quantity: 'quantity',
  price: 'price',
  productName: 'productName',
  productSku: 'productSku',
  selectedVariantName: 'selectedVariantName',
  selectedCustomizationOptions: 'selectedCustomizationOptions',
  createdAt: 'createdAt'
} as const

export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


export const OrderHistoryScalarFieldEnum = {
  id: 'id',
  orderId: 'orderId',
  status: 'status',
  timestamp: 'timestamp',
  notes: 'notes',
  userId: 'userId'
} as const

export type OrderHistoryScalarFieldEnum = (typeof OrderHistoryScalarFieldEnum)[keyof typeof OrderHistoryScalarFieldEnum]


export const ShippingMethodScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  cost: 'cost',
  isActive: 'isActive',
  description: 'description',
  estimatedDays: 'estimatedDays',
  freeAboveAmount: 'freeAboveAmount',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ShippingMethodScalarFieldEnum = (typeof ShippingMethodScalarFieldEnum)[keyof typeof ShippingMethodScalarFieldEnum]


export const PaymentMethodScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  isActive: 'isActive',
  description: 'description',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


export const UserAddressScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  name: 'name',
  firstName: 'firstName',
  lastName: 'lastName',
  phone: 'phone',
  email: 'email',
  company: 'company',
  vatNumber: 'vatNumber',
  country: 'country',
  region: 'region',
  city: 'city',
  postcode: 'postcode',
  addressLine1: 'addressLine1',
  addressLine2: 'addressLine2',
  isDefault: 'isDefault',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserAddressScalarFieldEnum = (typeof UserAddressScalarFieldEnum)[keyof typeof UserAddressScalarFieldEnum]


export const WishlistItemScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  productId: 'productId',
  customerId: 'customerId',
  createdAt: 'createdAt'
} as const

export type WishlistItemScalarFieldEnum = (typeof WishlistItemScalarFieldEnum)[keyof typeof WishlistItemScalarFieldEnum]


export const ReviewScalarFieldEnum = {
  id: 'id',
  productId: 'productId',
  userId: 'userId',
  rating: 'rating',
  title: 'title',
  comment: 'comment',
  isApproved: 'isApproved',
  tenantId: 'tenantId',
  customerId: 'customerId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


export const MediaScalarFieldEnum = {
  id: 'id',
  filename: 'filename',
  originalName: 'originalName',
  url: 'url',
  mimeType: 'mimeType',
  size: 'size',
  width: 'width',
  height: 'height',
  altText: 'altText',
  folder: 'folder',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


export const BlogPostScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  featuredImage: 'featuredImage',
  author: 'author',
  isPublished: 'isPublished',
  publishedAt: 'publishedAt',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


export const BlogPostTranslationScalarFieldEnum = {
  id: 'id',
  postId: 'postId',
  localeId: 'localeId',
  title: 'title',
  excerpt: 'excerpt',
  content: 'content'
} as const

export type BlogPostTranslationScalarFieldEnum = (typeof BlogPostTranslationScalarFieldEnum)[keyof typeof BlogPostTranslationScalarFieldEnum]


export const PageScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  type: 'type',
  isActive: 'isActive',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


export const PageTranslationScalarFieldEnum = {
  id: 'id',
  pageId: 'pageId',
  localeId: 'localeId',
  title: 'title',
  content: 'content'
} as const

export type PageTranslationScalarFieldEnum = (typeof PageTranslationScalarFieldEnum)[keyof typeof PageTranslationScalarFieldEnum]


export const CollectionScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  imageUrl: 'imageUrl',
  isActive: 'isActive',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CollectionScalarFieldEnum = (typeof CollectionScalarFieldEnum)[keyof typeof CollectionScalarFieldEnum]


export const CollectionTranslationScalarFieldEnum = {
  id: 'id',
  collectionId: 'collectionId',
  localeId: 'localeId',
  name: 'name',
  description: 'description'
} as const

export type CollectionTranslationScalarFieldEnum = (typeof CollectionTranslationScalarFieldEnum)[keyof typeof CollectionTranslationScalarFieldEnum]


export const CollectionProductScalarFieldEnum = {
  collectionId: 'collectionId',
  productId: 'productId',
  order: 'order'
} as const

export type CollectionProductScalarFieldEnum = (typeof CollectionProductScalarFieldEnum)[keyof typeof CollectionProductScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'BillingStatus'
 */
export type EnumBillingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingStatus'>
    


/**
 * Reference to a field of type 'BillingStatus[]'
 */
export type ListEnumBillingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingStatus[]'>
    


/**
 * Reference to a field of type 'BillingCycle'
 */
export type EnumBillingCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCycle'>
    


/**
 * Reference to a field of type 'BillingCycle[]'
 */
export type ListEnumBillingCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCycle[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'StaffRole'
 */
export type EnumStaffRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffRole'>
    


/**
 * Reference to a field of type 'StaffRole[]'
 */
export type ListEnumStaffRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffRole[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'UserRole'
 */
export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


/**
 * Reference to a field of type 'UserRole[]'
 */
export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


/**
 * Reference to a field of type 'ProductStatus'
 */
export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus'>
    


/**
 * Reference to a field of type 'ProductStatus[]'
 */
export type ListEnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus[]'>
    


/**
 * Reference to a field of type 'MeasurementUnit'
 */
export type EnumMeasurementUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeasurementUnit'>
    


/**
 * Reference to a field of type 'MeasurementUnit[]'
 */
export type ListEnumMeasurementUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeasurementUnit[]'>
    


/**
 * Reference to a field of type 'PurchaseType'
 */
export type EnumPurchaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseType'>
    


/**
 * Reference to a field of type 'PurchaseType[]'
 */
export type ListEnumPurchaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseType[]'>
    


/**
 * Reference to a field of type 'SubscriptionInterval[]'
 */
export type ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionInterval[]'>
    


/**
 * Reference to a field of type 'SubscriptionInterval'
 */
export type EnumSubscriptionIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionInterval'>
    


/**
 * Reference to a field of type 'MediaType'
 */
export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


/**
 * Reference to a field of type 'MediaType[]'
 */
export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


/**
 * Reference to a field of type 'PackageType'
 */
export type EnumPackageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageType'>
    


/**
 * Reference to a field of type 'PackageType[]'
 */
export type ListEnumPackageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageType[]'>
    


/**
 * Reference to a field of type 'CustomizationOptionType'
 */
export type EnumCustomizationOptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomizationOptionType'>
    


/**
 * Reference to a field of type 'CustomizationOptionType[]'
 */
export type ListEnumCustomizationOptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomizationOptionType[]'>
    


/**
 * Reference to a field of type 'DiscountType'
 */
export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


/**
 * Reference to a field of type 'DiscountType[]'
 */
export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


/**
 * Reference to a field of type 'DiscountScope'
 */
export type EnumDiscountScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountScope'>
    


/**
 * Reference to a field of type 'DiscountScope[]'
 */
export type ListEnumDiscountScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountScope[]'>
    


/**
 * Reference to a field of type 'OrderStatus'
 */
export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


/**
 * Reference to a field of type 'OrderStatus[]'
 */
export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


/**
 * Reference to a field of type 'PaymentStatus'
 */
export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


/**
 * Reference to a field of type 'PaymentStatus[]'
 */
export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


/**
 * Reference to a field of type 'ShippingMethodType'
 */
export type EnumShippingMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShippingMethodType'>
    


/**
 * Reference to a field of type 'ShippingMethodType[]'
 */
export type ListEnumShippingMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShippingMethodType[]'>
    


/**
 * Reference to a field of type 'PaymentMethodType'
 */
export type EnumPaymentMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodType'>
    


/**
 * Reference to a field of type 'PaymentMethodType[]'
 */
export type ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodType[]'>
    


/**
 * Reference to a field of type 'PageType'
 */
export type EnumPageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PageType'>
    


/**
 * Reference to a field of type 'PageType[]'
 */
export type ListEnumPageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PageType[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  tenant?: Prisma.TenantOmit
  tenantStaff?: Prisma.TenantStaffOmit
  tenantDomain?: Prisma.TenantDomainOmit
  customer?: Prisma.CustomerOmit
  customerAddress?: Prisma.CustomerAddressOmit
  customerSession?: Prisma.CustomerSessionOmit
  user?: Prisma.UserOmit
  account?: Prisma.AccountOmit
  session?: Prisma.SessionOmit
  verification?: Prisma.VerificationOmit
  emailVerificationToken?: Prisma.EmailVerificationTokenOmit
  passwordResetToken?: Prisma.PasswordResetTokenOmit
  locale?: Prisma.LocaleOmit
  currency?: Prisma.CurrencyOmit
  brand?: Prisma.BrandOmit
  brandTranslation?: Prisma.BrandTranslationOmit
  category?: Prisma.CategoryOmit
  categoryTranslation?: Prisma.CategoryTranslationOmit
  product?: Prisma.ProductOmit
  productTranslation?: Prisma.ProductTranslationOmit
  productMedia?: Prisma.ProductMediaOmit
  productSpecification?: Prisma.ProductSpecificationOmit
  productSpecificationTranslation?: Prisma.ProductSpecificationTranslationOmit
  productShippingInfo?: Prisma.ProductShippingInfoOmit
  productDownload?: Prisma.ProductDownloadOmit
  filter?: Prisma.FilterOmit
  filterAttribute?: Prisma.FilterAttributeOmit
  filterAttributeTranslation?: Prisma.FilterAttributeTranslationOmit
  productFilter?: Prisma.ProductFilterOmit
  categoryFilter?: Prisma.CategoryFilterOmit
  productVariant?: Prisma.ProductVariantOmit
  variantOptionMeta?: Prisma.VariantOptionMetaOmit
  productCustomizationOption?: Prisma.ProductCustomizationOptionOmit
  productCustomizationOptionTranslation?: Prisma.ProductCustomizationOptionTranslationOmit
  productCustomizationOptionValue?: Prisma.ProductCustomizationOptionValueOmit
  productCustomizationOptionValueTranslation?: Prisma.ProductCustomizationOptionValueTranslationOmit
  discount?: Prisma.DiscountOmit
  discountProduct?: Prisma.DiscountProductOmit
  discountCategory?: Prisma.DiscountCategoryOmit
  discountBrand?: Prisma.DiscountBrandOmit
  promoCode?: Prisma.PromoCodeOmit
  promoCodeProduct?: Prisma.PromoCodeProductOmit
  promoCodeCategory?: Prisma.PromoCodeCategoryOmit
  promoCodeBrand?: Prisma.PromoCodeBrandOmit
  giftCard?: Prisma.GiftCardOmit
  cart?: Prisma.CartOmit
  cartItem?: Prisma.CartItemOmit
  order?: Prisma.OrderOmit
  orderItem?: Prisma.OrderItemOmit
  orderHistory?: Prisma.OrderHistoryOmit
  shippingMethod?: Prisma.ShippingMethodOmit
  paymentMethod?: Prisma.PaymentMethodOmit
  userAddress?: Prisma.UserAddressOmit
  wishlistItem?: Prisma.WishlistItemOmit
  review?: Prisma.ReviewOmit
  media?: Prisma.MediaOmit
  blogPost?: Prisma.BlogPostOmit
  blogPostTranslation?: Prisma.BlogPostTranslationOmit
  page?: Prisma.PageOmit
  pageTranslation?: Prisma.PageTranslationOmit
  collection?: Prisma.CollectionOmit
  collectionTranslation?: Prisma.CollectionTranslationOmit
  collectionProduct?: Prisma.CollectionProductOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

